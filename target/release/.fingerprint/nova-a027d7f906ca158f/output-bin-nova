{"$message_type":"diagnostic","message":"unresolved imports `crossterm::terminal::DisableMouseCapture`, `crossterm::terminal::EnableMouseCapture`","code":{"code":"E0432","explanation":"An import was unresolved.\n\nErroneous code example:\n\n```compile_fail,E0432\nuse something::Foo; // error: unresolved import `something::Foo`.\n```\n\nIn Rust 2015, paths in `use` statements are relative to the crate root. To\nimport items relative to the current and parent modules, use the `self::` and\n`super::` prefixes, respectively.\n\nIn Rust 2018 or later, paths in `use` statements are relative to the current\nmodule unless they begin with the name of a crate or a literal `crate::`, in\nwhich case they start from the crate root. As in Rust 2015 code, the `self::`\nand `super::` prefixes refer to the current and parent modules respectively.\n\nAlso verify that you didn't misspell the import name and that the import exists\nin the module from where you tried to import it. Example:\n\n```\nuse self::something::Foo; // Ok.\n\nmod something {\n    pub struct Foo;\n}\n# fn main() {}\n```\n\nIf you tried to use a module from an external crate and are using Rust 2015,\nyou may have missed the `extern crate` declaration (which is usually placed in\nthe crate root):\n\n```edition2015\nextern crate core; // Required to use the `core` crate in Rust 2015.\n\nuse core::any;\n# fn main() {}\n```\n\nSince Rust 2018 the `extern crate` declaration is not required and\nyou can instead just `use` it:\n\n```edition2018\nuse core::any; // No extern crate required in Rust 2018.\n# fn main() {}\n```\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":227,"byte_end":246,"line_start":7,"line_end":7,"column_start":95,"column_end":114,"is_primary":true,"text":[{"text":"    terminal::{disable_raw_mode, enable_raw_mode, EnterAlternateScreen, LeaveAlternateScreen, DisableMouseCapture, EnableMouseCapture},","highlight_start":95,"highlight_end":114}],"label":"no `DisableMouseCapture` in `terminal`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":248,"byte_end":266,"line_start":7,"line_end":7,"column_start":116,"column_end":134,"is_primary":true,"text":[{"text":"    terminal::{disable_raw_mode, enable_raw_mode, EnterAlternateScreen, LeaveAlternateScreen, DisableMouseCapture, EnableMouseCapture},","highlight_start":116,"highlight_end":134}],"label":"no `EnableMouseCapture` in `terminal`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing one of these structs instead:\ncrate::event::DisableMouseCapture\ncrossterm::event::DisableMouseCapture","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"consider importing one of these structs instead:\ncrate::event::EnableMouseCapture\ncrossterm::event::EnableMouseCapture","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0432]\u001b[0m\u001b[1m: unresolved imports `crossterm::terminal::DisableMouseCapture`, `crossterm::terminal::EnableMouseCapture`\u001b[0m\n \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:7:95\n  \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m7\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     terminal::{disable_raw_mode, enable_raw_mode, EnterAlternateScreen, LeaveAlternateScreen, DisableMouseCapture, EnableMouseCapture},\n  \u001b[1m\u001b[94m|\u001b[0m                                                                                               \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^\u001b[0m  \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mno `EnableMouseCapture` in `terminal`\u001b[0m\n  \u001b[1m\u001b[94m|\u001b[0m                                                                                               \u001b[1m\u001b[91m|\u001b[0m\n  \u001b[1m\u001b[94m|\u001b[0m                                                                                               \u001b[1m\u001b[91mno `DisableMouseCapture` in `terminal`\u001b[0m\n  \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: consider importing one of these structs instead:\n          crate::event::DisableMouseCapture\n          crossterm::event::DisableMouseCapture\n  \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: consider importing one of these structs instead:\n          crate::event::EnableMouseCapture\n          crossterm::event::EnableMouseCapture\n\n"}
{"$message_type":"diagnostic","message":"unresolved imports `crossterm::event::Key`, `crossterm::event::KeyMod`","code":{"code":"E0432","explanation":"An import was unresolved.\n\nErroneous code example:\n\n```compile_fail,E0432\nuse something::Foo; // error: unresolved import `something::Foo`.\n```\n\nIn Rust 2015, paths in `use` statements are relative to the crate root. To\nimport items relative to the current and parent modules, use the `self::` and\n`super::` prefixes, respectively.\n\nIn Rust 2018 or later, paths in `use` statements are relative to the current\nmodule unless they begin with the name of a crate or a literal `crate::`, in\nwhich case they start from the crate root. As in Rust 2015 code, the `self::`\nand `super::` prefixes refer to the current and parent modules respectively.\n\nAlso verify that you didn't misspell the import name and that the import exists\nin the module from where you tried to import it. Example:\n\n```\nuse self::something::Foo; // Ok.\n\nmod something {\n    pub struct Foo;\n}\n# fn main() {}\n```\n\nIf you tried to use a module from an external crate and are using Rust 2015,\nyou may have missed the `extern crate` declaration (which is usually placed in\nthe crate root):\n\n```edition2015\nextern crate core; // Required to use the `core` crate in Rust 2015.\n\nuse core::any;\n# fn main() {}\n```\n\nSince Rust 2018 the `extern crate` declaration is not required and\nyou can instead just `use` it:\n\n```edition2018\nuse core::any; // No extern crate required in Rust 2018.\n# fn main() {}\n```\n"},"level":"error","spans":[{"file_name":"src/input/keymap.rs","byte_start":23,"byte_end":26,"line_start":1,"line_end":1,"column_start":24,"column_end":27,"is_primary":true,"text":[{"text":"use crossterm::event::{Key, KeyCode, KeyMod};","highlight_start":24,"highlight_end":27}],"label":"no `Key` in `event`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/input/keymap.rs","byte_start":37,"byte_end":43,"line_start":1,"line_end":1,"column_start":38,"column_end":44,"is_primary":true,"text":[{"text":"use crossterm::event::{Key, KeyCode, KeyMod};","highlight_start":38,"highlight_end":44}],"label":"no `KeyMod` in `event`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing one of these variants instead:\ncrate::Event::Key\ncrossterm::event::Event::Key","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"a similar name exists in the module","code":null,"level":"help","spans":[{"file_name":"src/input/keymap.rs","byte_start":37,"byte_end":43,"line_start":1,"line_end":1,"column_start":38,"column_end":44,"is_primary":true,"text":[{"text":"use crossterm::event::{Key, KeyCode, KeyMod};","highlight_start":38,"highlight_end":44}],"label":null,"suggested_replacement":"KeyCode","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0432]\u001b[0m\u001b[1m: unresolved imports `crossterm::event::Key`, `crossterm::event::KeyMod`\u001b[0m\n \u001b[1m\u001b[94m--> \u001b[0msrc/input/keymap.rs:1:24\n  \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m1\u001b[0m \u001b[1m\u001b[94m|\u001b[0m use crossterm::event::{Key, KeyCode, KeyMod};\n  \u001b[1m\u001b[94m|\u001b[0m                        \u001b[1m\u001b[91m^^^\u001b[0m           \u001b[1m\u001b[91m^^^^^^\u001b[0m\n  \u001b[1m\u001b[94m|\u001b[0m                        \u001b[1m\u001b[91m|\u001b[0m             \u001b[1m\u001b[91m|\u001b[0m\n  \u001b[1m\u001b[94m|\u001b[0m                        \u001b[1m\u001b[91m|\u001b[0m             \u001b[1m\u001b[91mno `KeyMod` in `event`\u001b[0m\n  \u001b[1m\u001b[94m|\u001b[0m                        \u001b[1m\u001b[91m|\u001b[0m             \u001b[1m\u001b[91mhelp: a similar name exists in the module: `KeyCode`\u001b[0m\n  \u001b[1m\u001b[94m|\u001b[0m                        \u001b[1m\u001b[91mno `Key` in `event`\u001b[0m\n  \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: consider importing one of these variants instead:\n          crate::Event::Key\n          crossterm::event::Event::Key\n\n"}
{"$message_type":"diagnostic","message":"unresolved import `serde`","code":{"code":"E0432","explanation":"An import was unresolved.\n\nErroneous code example:\n\n```compile_fail,E0432\nuse something::Foo; // error: unresolved import `something::Foo`.\n```\n\nIn Rust 2015, paths in `use` statements are relative to the crate root. To\nimport items relative to the current and parent modules, use the `self::` and\n`super::` prefixes, respectively.\n\nIn Rust 2018 or later, paths in `use` statements are relative to the current\nmodule unless they begin with the name of a crate or a literal `crate::`, in\nwhich case they start from the crate root. As in Rust 2015 code, the `self::`\nand `super::` prefixes refer to the current and parent modules respectively.\n\nAlso verify that you didn't misspell the import name and that the import exists\nin the module from where you tried to import it. Example:\n\n```\nuse self::something::Foo; // Ok.\n\nmod something {\n    pub struct Foo;\n}\n# fn main() {}\n```\n\nIf you tried to use a module from an external crate and are using Rust 2015,\nyou may have missed the `extern crate` declaration (which is usually placed in\nthe crate root):\n\n```edition2015\nextern crate core; // Required to use the `core` crate in Rust 2015.\n\nuse core::any;\n# fn main() {}\n```\n\nSince Rust 2018 the `extern crate` declaration is not required and\nyou can instead just `use` it:\n\n```edition2018\nuse core::any; // No extern crate required in Rust 2018.\n# fn main() {}\n```\n"},"level":"error","spans":[{"file_name":"src/buffer/cursor.rs","byte_start":4,"byte_end":9,"line_start":1,"line_end":1,"column_start":5,"column_end":10,"is_primary":true,"text":[{"text":"use serde::{Deserialize, Serialize};","highlight_start":5,"highlight_end":10}],"label":"use of unresolved module or unlinked crate `serde`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"if you wanted to use a crate named `serde`, use `cargo add serde` to add it to your `Cargo.toml`","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0432]\u001b[0m\u001b[1m: unresolved import `serde`\u001b[0m\n \u001b[1m\u001b[94m--> \u001b[0msrc/buffer/cursor.rs:1:5\n  \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m1\u001b[0m \u001b[1m\u001b[94m|\u001b[0m use serde::{Deserialize, Serialize};\n  \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[91m^^^^^\u001b[0m \u001b[1m\u001b[91muse of unresolved module or unlinked crate `serde`\u001b[0m\n  \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: if you wanted to use a crate named `serde`, use `cargo add serde` to add it to your `Cargo.toml`\n\n"}
{"$message_type":"diagnostic","message":"unresolved import `serde`","code":{"code":"E0432","explanation":"An import was unresolved.\n\nErroneous code example:\n\n```compile_fail,E0432\nuse something::Foo; // error: unresolved import `something::Foo`.\n```\n\nIn Rust 2015, paths in `use` statements are relative to the crate root. To\nimport items relative to the current and parent modules, use the `self::` and\n`super::` prefixes, respectively.\n\nIn Rust 2018 or later, paths in `use` statements are relative to the current\nmodule unless they begin with the name of a crate or a literal `crate::`, in\nwhich case they start from the crate root. As in Rust 2015 code, the `self::`\nand `super::` prefixes refer to the current and parent modules respectively.\n\nAlso verify that you didn't misspell the import name and that the import exists\nin the module from where you tried to import it. Example:\n\n```\nuse self::something::Foo; // Ok.\n\nmod something {\n    pub struct Foo;\n}\n# fn main() {}\n```\n\nIf you tried to use a module from an external crate and are using Rust 2015,\nyou may have missed the `extern crate` declaration (which is usually placed in\nthe crate root):\n\n```edition2015\nextern crate core; // Required to use the `core` crate in Rust 2015.\n\nuse core::any;\n# fn main() {}\n```\n\nSince Rust 2018 the `extern crate` declaration is not required and\nyou can instead just `use` it:\n\n```edition2018\nuse core::any; // No extern crate required in Rust 2018.\n# fn main() {}\n```\n"},"level":"error","spans":[{"file_name":"src/buffer/history.rs","byte_start":4,"byte_end":9,"line_start":1,"line_end":1,"column_start":5,"column_end":10,"is_primary":true,"text":[{"text":"use serde::{Deserialize, Serialize};","highlight_start":5,"highlight_end":10}],"label":"use of unresolved module or unlinked crate `serde`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"if you wanted to use a crate named `serde`, use `cargo add serde` to add it to your `Cargo.toml`","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0432]\u001b[0m\u001b[1m: unresolved import `serde`\u001b[0m\n \u001b[1m\u001b[94m--> \u001b[0msrc/buffer/history.rs:1:5\n  \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m1\u001b[0m \u001b[1m\u001b[94m|\u001b[0m use serde::{Deserialize, Serialize};\n  \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[91m^^^^^\u001b[0m \u001b[1m\u001b[91muse of unresolved module or unlinked crate `serde`\u001b[0m\n  \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: if you wanted to use a crate named `serde`, use `cargo add serde` to add it to your `Cargo.toml`\n\n"}
{"$message_type":"diagnostic","message":"unresolved import `serde`","code":{"code":"E0432","explanation":"An import was unresolved.\n\nErroneous code example:\n\n```compile_fail,E0432\nuse something::Foo; // error: unresolved import `something::Foo`.\n```\n\nIn Rust 2015, paths in `use` statements are relative to the crate root. To\nimport items relative to the current and parent modules, use the `self::` and\n`super::` prefixes, respectively.\n\nIn Rust 2018 or later, paths in `use` statements are relative to the current\nmodule unless they begin with the name of a crate or a literal `crate::`, in\nwhich case they start from the crate root. As in Rust 2015 code, the `self::`\nand `super::` prefixes refer to the current and parent modules respectively.\n\nAlso verify that you didn't misspell the import name and that the import exists\nin the module from where you tried to import it. Example:\n\n```\nuse self::something::Foo; // Ok.\n\nmod something {\n    pub struct Foo;\n}\n# fn main() {}\n```\n\nIf you tried to use a module from an external crate and are using Rust 2015,\nyou may have missed the `extern crate` declaration (which is usually placed in\nthe crate root):\n\n```edition2015\nextern crate core; // Required to use the `core` crate in Rust 2015.\n\nuse core::any;\n# fn main() {}\n```\n\nSince Rust 2018 the `extern crate` declaration is not required and\nyou can instead just `use` it:\n\n```edition2018\nuse core::any; // No extern crate required in Rust 2018.\n# fn main() {}\n```\n"},"level":"error","spans":[{"file_name":"src/config/settings.rs","byte_start":4,"byte_end":9,"line_start":1,"line_end":1,"column_start":5,"column_end":10,"is_primary":true,"text":[{"text":"use serde::{Deserialize, Serialize};","highlight_start":5,"highlight_end":10}],"label":"use of unresolved module or unlinked crate `serde`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"if you wanted to use a crate named `serde`, use `cargo add serde` to add it to your `Cargo.toml`","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0432]\u001b[0m\u001b[1m: unresolved import `serde`\u001b[0m\n \u001b[1m\u001b[94m--> \u001b[0msrc/config/settings.rs:1:5\n  \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m1\u001b[0m \u001b[1m\u001b[94m|\u001b[0m use serde::{Deserialize, Serialize};\n  \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[91m^^^^^\u001b[0m \u001b[1m\u001b[91muse of unresolved module or unlinked crate `serde`\u001b[0m\n  \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: if you wanted to use a crate named `serde`, use `cargo add serde` to add it to your `Cargo.toml`\n\n"}
{"$message_type":"diagnostic","message":"failed to resolve: could not find `KeyMod` in `event`","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared module or unlinked crate\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":14694,"byte_end":14700,"line_start":410,"line_end":410,"column_start":99,"column_end":105,"is_primary":true,"text":[{"text":"                    if key.code == KeyCode::Char('q') && key.modifiers.contains(crossterm::event::KeyMod::CONTROL) {","highlight_start":99,"highlight_end":105}],"label":"could not find `KeyMod` in `event`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"an enum with a similar name exists","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":14694,"byte_end":14700,"line_start":410,"line_end":410,"column_start":99,"column_end":105,"is_primary":true,"text":[{"text":"                    if key.code == KeyCode::Char('q') && key.modifiers.contains(crossterm::event::KeyMod::CONTROL) {","highlight_start":99,"highlight_end":105}],"label":null,"suggested_replacement":"KeyCode","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0433]\u001b[0m\u001b[1m: failed to resolve: could not find `KeyMod` in `event`\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:410:99\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m410\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                     if key.code == KeyCode::Char('q') && key.modifiers.contains(crossterm::event::KeyMod::CONTROL) {\n    \u001b[1m\u001b[94m|\u001b[0m                                                                                                   \u001b[1m\u001b[91m^^^^^^\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                                                                                                   \u001b[1m\u001b[91m|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                                                                                                   \u001b[1m\u001b[91mcould not find `KeyMod` in `event`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                                                                                                   \u001b[1m\u001b[91mhelp: an enum with a similar name exists: `KeyCode`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"failed to resolve: could not find `KeyMod` in `event`","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared module or unlinked crate\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":14873,"byte_end":14879,"line_start":414,"line_end":414,"column_start":87,"column_end":93,"is_primary":true,"text":[{"text":"                    if key.modifiers.is_empty() || key.modifiers == crossterm::event::KeyMod::SHIFT {","highlight_start":87,"highlight_end":93}],"label":"could not find `KeyMod` in `event`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"an enum with a similar name exists","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":14873,"byte_end":14879,"line_start":414,"line_end":414,"column_start":87,"column_end":93,"is_primary":true,"text":[{"text":"                    if key.modifiers.is_empty() || key.modifiers == crossterm::event::KeyMod::SHIFT {","highlight_start":87,"highlight_end":93}],"label":null,"suggested_replacement":"KeyCode","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0433]\u001b[0m\u001b[1m: failed to resolve: could not find `KeyMod` in `event`\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:414:87\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m414\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                     if key.modifiers.is_empty() || key.modifiers == crossterm::event::KeyMod::SHIFT {\n    \u001b[1m\u001b[94m|\u001b[0m                                                                                       \u001b[1m\u001b[91m^^^^^^\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                                                                                       \u001b[1m\u001b[91m|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                                                                                       \u001b[1m\u001b[91mcould not find `KeyMod` in `event`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                                                                                       \u001b[1m\u001b[91mhelp: an enum with a similar name exists: `KeyCode`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"expected type, found function `ropey::str_utils::byte_to_char_idx`","code":{"code":"E0573","explanation":"Something other than a type has been used when one was expected.\n\nErroneous code examples:\n\n```compile_fail,E0573\nenum Dragon {\n    Born,\n}\n\nfn oblivion() -> Dragon::Born { // error!\n    Dragon::Born\n}\n\nconst HOBBIT: u32 = 2;\nimpl HOBBIT {} // error!\n\nenum Wizard {\n    Gandalf,\n    Saruman,\n}\n\ntrait Isengard {\n    fn wizard(_: Wizard::Saruman); // error!\n}\n```\n\nIn all these errors, a type was expected. For example, in the first error, if\nwe want to return the `Born` variant from the `Dragon` enum, we must set the\nfunction to return the enum and not its variant:\n\n```\nenum Dragon {\n    Born,\n}\n\nfn oblivion() -> Dragon { // ok!\n    Dragon::Born\n}\n```\n\nIn the second error, you can't implement something on an item, only on types.\nWe would need to create a new type if we wanted to do something similar:\n\n```\nstruct Hobbit(u32); // we create a new type\n\nconst HOBBIT: Hobbit = Hobbit(2);\nimpl Hobbit {} // ok!\n```\n\nIn the third case, we tried to only expect one variant of the `Wizard` enum,\nwhich is not possible. To make this work, we need to using pattern matching\nover the `Wizard` enum:\n\n```\nenum Wizard {\n    Gandalf,\n    Saruman,\n}\n\ntrait Isengard {\n    fn wizard(w: Wizard) { // ok!\n        match w {\n            Wizard::Saruman => {\n                // do something\n            }\n            _ => {} // ignore everything else\n        }\n    }\n}\n```\n"},"level":"error","spans":[{"file_name":"src/buffer/buffer.rs","byte_start":1151,"byte_end":1185,"line_start":48,"line_end":48,"column_start":55,"column_end":89,"is_primary":true,"text":[{"text":"    pub fn get_line(&self, line_idx: usize) -> Option<ropey::str_utils::byte_to_char_idx> {","highlight_start":55,"highlight_end":89}],"label":"not a type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0573]\u001b[0m\u001b[1m: expected type, found function `ropey::str_utils::byte_to_char_idx`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/buffer/buffer.rs:48:55\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m48\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub fn get_line(&self, line_idx: usize) -> Option<ropey::str_utils::byte_to_char_idx> {\n   \u001b[1m\u001b[94m|\u001b[0m                                                       \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mnot a type\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused import: `Position`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/buffer/mod.rs","byte_start":99,"byte_end":107,"line_start":6,"line_end":6,"column_start":26,"column_end":34,"is_primary":true,"text":[{"text":"pub use cursor::{Cursor, Position};","highlight_start":26,"highlight_end":34}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"remove the unused import","code":null,"level":"help","spans":[{"file_name":"src/buffer/mod.rs","byte_start":97,"byte_end":107,"line_start":6,"line_end":6,"column_start":24,"column_end":34,"is_primary":true,"text":[{"text":"pub use cursor::{Cursor, Position};","highlight_start":24,"highlight_end":34}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"src/buffer/mod.rs","byte_start":90,"byte_end":91,"line_start":6,"line_end":6,"column_start":17,"column_end":18,"is_primary":true,"text":[{"text":"pub use cursor::{Cursor, Position};","highlight_start":17,"highlight_end":18}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"src/buffer/mod.rs","byte_start":107,"byte_end":108,"line_start":6,"line_end":6,"column_start":34,"column_end":35,"is_primary":true,"text":[{"text":"pub use cursor::{Cursor, Position};","highlight_start":34,"highlight_end":35}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unused import: `Position`\u001b[0m\n \u001b[1m\u001b[94m--> \u001b[0msrc/buffer/mod.rs:6:26\n  \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m6\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub use cursor::{Cursor, Position};\n  \u001b[1m\u001b[94m|\u001b[0m                          \u001b[1m\u001b[33m^^^^^^^^\u001b[0m\n  \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: `#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default\n\n"}
{"$message_type":"diagnostic","message":"unused import: `ratatui::Frame`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/ui/layout.rs","byte_start":64,"byte_end":78,"line_start":2,"line_end":2,"column_start":5,"column_end":19,"is_primary":true,"text":[{"text":"use ratatui::Frame;","highlight_start":5,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the whole `use` item","code":null,"level":"help","spans":[{"file_name":"src/ui/layout.rs","byte_start":60,"byte_end":80,"line_start":2,"line_end":3,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use ratatui::Frame;","highlight_start":1,"highlight_end":20},{"text":"","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unused import: `ratatui::Frame`\u001b[0m\n \u001b[1m\u001b[94m--> \u001b[0msrc/ui/layout.rs:2:5\n  \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m2\u001b[0m \u001b[1m\u001b[94m|\u001b[0m use ratatui::Frame;\n  \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[33m^^^^^^^^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no function or associated item named `from_file` found for struct `Rope` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/buffer/buffer.rs","byte_start":472,"byte_end":481,"line_start":23,"line_end":23,"column_start":26,"column_end":35,"is_primary":true,"text":[{"text":"        let rope = Rope::from_file(&path).ok()?;","highlight_start":26,"highlight_end":35}],"label":"function or associated item not found in `Rope`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"if you're trying to build a new `Rope` consider using one of the following associated functions:\nRope::new\nRope::from_str\nRope::from_reader","code":null,"level":"note","spans":[{"file_name":"/root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/ropey-1.6.1/src/rope.rs","byte_start":2923,"byte_end":2943,"line_start":92,"line_end":92,"column_start":5,"column_end":25,"is_primary":true,"text":[{"text":"    pub fn new() -> Self {","highlight_start":5,"highlight_end":25}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/ropey-1.6.1/src/rope.rs","byte_start":3163,"byte_end":3198,"line_start":103,"line_end":103,"column_start":5,"column_end":40,"is_primary":true,"text":[{"text":"    pub fn from_str(text: &str) -> Self {","highlight_start":5,"highlight_end":40}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/ropey-1.6.1/src/rope.rs","byte_start":4080,"byte_end":4146,"line_start":129,"line_end":129,"column_start":5,"column_end":71,"is_primary":true,"text":[{"text":"    pub fn from_reader<T: io::Read>(mut reader: T) -> io::Result<Self> {","highlight_start":5,"highlight_end":71}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"there is an associated function `from_iter` with a similar name","code":null,"level":"help","spans":[{"file_name":"src/buffer/buffer.rs","byte_start":472,"byte_end":481,"line_start":23,"line_end":23,"column_start":26,"column_end":35,"is_primary":true,"text":[{"text":"        let rope = Rope::from_file(&path).ok()?;","highlight_start":26,"highlight_end":35}],"label":null,"suggested_replacement":"from_iter","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m: no function or associated item named `from_file` found for struct `Rope` in the current scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/buffer/buffer.rs:23:26\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m23\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         let rope = Rope::from_file(&path).ok()?;\n    \u001b[1m\u001b[94m|\u001b[0m                          \u001b[1m\u001b[91m^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mfunction or associated item not found in `Rope`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: if you're trying to build a new `Rope` consider using one of the following associated functions:\n      Rope::new\n      Rope::from_str\n      Rope::from_reader\n   \u001b[1m\u001b[94m--> \u001b[0m/root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/ropey-1.6.1/src/rope.rs:92:5\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m92\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub fn new() -> Self {\n    \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m103\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub fn from_str(text: &str) -> Self {\n    \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m129\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub fn from_reader<T: io::Read>(mut reader: T) -> io::Result<Self> {\n    \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: there is an associated function `from_iter` with a similar name\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m23\u001b[0m \u001b[91m- \u001b[0m        let rope = Rope::\u001b[91mfrom_file\u001b[0m(&path).ok()?;\n \u001b[1m\u001b[94m23\u001b[0m \u001b[92m+ \u001b[0m        let rope = Rope::\u001b[92mfrom_iter\u001b[0m(&path).ok()?;\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no method named `insert_str` found for struct `Rope` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/buffer/buffer.rs","byte_start":893,"byte_end":903,"line_start":39,"line_end":39,"column_start":19,"column_end":29,"is_primary":true,"text":[{"text":"        self.rope.insert_str(idx, s);","highlight_start":19,"highlight_end":29}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"there is a method `insert` with a similar name","code":null,"level":"help","spans":[{"file_name":"src/buffer/buffer.rs","byte_start":893,"byte_end":903,"line_start":39,"line_end":39,"column_start":19,"column_end":29,"is_primary":true,"text":[{"text":"        self.rope.insert_str(idx, s);","highlight_start":19,"highlight_end":29}],"label":null,"suggested_replacement":"insert","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m: no method named `insert_str` found for struct `Rope` in the current scope\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/buffer/buffer.rs:39:19\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m39\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         self.rope.insert_str(idx, s);\n   \u001b[1m\u001b[94m|\u001b[0m                   \u001b[1m\u001b[91m^^^^^^^^^^\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: there is a method `insert` with a similar name\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m39\u001b[0m \u001b[91m- \u001b[0m        self.rope.\u001b[91minsert_str\u001b[0m(idx, s);\n\u001b[1m\u001b[94m39\u001b[0m \u001b[92m+ \u001b[0m        self.rope.\u001b[92minsert\u001b[0m(idx, s);\n   \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"src/buffer/buffer.rs","byte_start":1061,"byte_end":1089,"line_start":45,"line_end":45,"column_start":9,"column_end":37,"is_primary":true,"text":[{"text":"        self.rope.remove(start..end)","highlight_start":9,"highlight_end":37}],"label":"expected `String`, found `()`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/buffer/buffer.rs","byte_start":1011,"byte_end":1017,"line_start":43,"line_end":43,"column_start":59,"column_end":65,"is_primary":false,"text":[{"text":"    pub fn remove(&mut self, start: usize, end: usize) -> String {","highlight_start":59,"highlight_end":65}],"label":"expected `std::string::String` because of return type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"method `remove` modifies its receiver in-place","code":null,"level":"note","spans":[{"file_name":"src/buffer/buffer.rs","byte_start":1071,"byte_end":1077,"line_start":45,"line_end":45,"column_start":19,"column_end":25,"is_primary":true,"text":[{"text":"        self.rope.remove(start..end)","highlight_start":19,"highlight_end":25}],"label":"this call modifies its receiver in-place","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m: mismatched types\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/buffer/buffer.rs:45:9\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m43\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub fn remove(&mut self, start: usize, end: usize) -> String {\n   \u001b[1m\u001b[94m|\u001b[0m                                                           \u001b[1m\u001b[94m------\u001b[0m \u001b[1m\u001b[94mexpected `std::string::String` because of return type\u001b[0m\n\u001b[1m\u001b[94m44\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         self.is_modified = true;\n\u001b[1m\u001b[94m45\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         self.rope.remove(start..end)\n   \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mexpected `String`, found `()`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: method `remove` modifies its receiver in-place\n  \u001b[1m\u001b[94m--> \u001b[0msrc/buffer/buffer.rs:45:19\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m45\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         self.rope.remove(start..end)\n   \u001b[1m\u001b[94m|\u001b[0m                   \u001b[1m\u001b[92m^^^^^^\u001b[0m \u001b[1m\u001b[92mthis call modifies its receiver in-place\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `&PathBuf: std::io::Write` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/buffer/buffer.rs","byte_start":1871,"byte_end":1875,"line_start":74,"line_end":74,"column_start":32,"column_end":36,"is_primary":true,"text":[{"text":"            self.rope.write_to(path)?;","highlight_start":32,"highlight_end":36}],"label":"the trait `std::io::Write` is not implemented for `&PathBuf`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/buffer/buffer.rs","byte_start":1862,"byte_end":1870,"line_start":74,"line_end":74,"column_start":23,"column_end":31,"is_primary":false,"text":[{"text":"            self.rope.write_to(path)?;","highlight_start":23,"highlight_end":31}],"label":"required by a bound introduced by this call","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"required by a bound in `Rope::write_to`","code":null,"level":"note","spans":[{"file_name":"/root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/ropey-1.6.1/src/rope.rs","byte_start":7674,"byte_end":7683,"line_start":216,"line_end":216,"column_start":24,"column_end":33,"is_primary":true,"text":[{"text":"    pub fn write_to<T: io::Write>(&self, mut writer: T) -> io::Result<()> {","highlight_start":24,"highlight_end":33}],"label":"required by this bound in `Rope::write_to`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `&PathBuf: std::io::Write` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/buffer/buffer.rs:74:32\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m74\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             self.rope.write_to(path)?;\n    \u001b[1m\u001b[94m|\u001b[0m                       \u001b[1m\u001b[94m--------\u001b[0m \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `std::io::Write` is not implemented for `&PathBuf`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                       \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                       \u001b[1m\u001b[94mrequired by a bound introduced by this call\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `Rope::write_to`\n   \u001b[1m\u001b[94m--> \u001b[0m/root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/ropey-1.6.1/src/rope.rs:216:24\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m216\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub fn write_to<T: io::Write>(&self, mut writer: T) -> io::Result<()> {\n    \u001b[1m\u001b[94m|\u001b[0m                        \u001b[1m\u001b[92m^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `Rope::write_to`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `&PathBuf: std::io::Write` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/buffer/buffer.rs","byte_start":2046,"byte_end":2051,"line_start":81,"line_end":81,"column_start":28,"column_end":33,"is_primary":true,"text":[{"text":"        self.rope.write_to(&path)?;","highlight_start":28,"highlight_end":33}],"label":"the trait `std::io::Write` is not implemented for `&PathBuf`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/buffer/buffer.rs","byte_start":2037,"byte_end":2045,"line_start":81,"line_end":81,"column_start":19,"column_end":27,"is_primary":false,"text":[{"text":"        self.rope.write_to(&path)?;","highlight_start":19,"highlight_end":27}],"label":"required by a bound introduced by this call","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"required by a bound in `Rope::write_to`","code":null,"level":"note","spans":[{"file_name":"/root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/ropey-1.6.1/src/rope.rs","byte_start":7674,"byte_end":7683,"line_start":216,"line_end":216,"column_start":24,"column_end":33,"is_primary":true,"text":[{"text":"    pub fn write_to<T: io::Write>(&self, mut writer: T) -> io::Result<()> {","highlight_start":24,"highlight_end":33}],"label":"required by this bound in `Rope::write_to`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `&PathBuf: std::io::Write` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/buffer/buffer.rs:81:28\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m81\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         self.rope.write_to(&path)?;\n    \u001b[1m\u001b[94m|\u001b[0m                   \u001b[1m\u001b[94m--------\u001b[0m \u001b[1m\u001b[91m^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `std::io::Write` is not implemented for `&PathBuf`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                   \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                   \u001b[1m\u001b[94mrequired by a bound introduced by this call\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `Rope::write_to`\n   \u001b[1m\u001b[94m--> \u001b[0m/root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/ropey-1.6.1/src/rope.rs:216:24\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m216\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub fn write_to<T: io::Write>(&self, mut writer: T) -> io::Result<()> {\n    \u001b[1m\u001b[94m|\u001b[0m                        \u001b[1m\u001b[92m^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `Rope::write_to`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no method named `len_chars` found for struct `std::string::String` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/buffer/cursor.rs","byte_start":2879,"byte_end":2888,"line_start":99,"line_end":99,"column_start":34,"column_end":43,"is_primary":true,"text":[{"text":"        let line_len = line_text.len_chars();","highlight_start":34,"highlight_end":43}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"there is a method `chars` with a similar name","code":null,"level":"help","spans":[{"file_name":"src/buffer/cursor.rs","byte_start":2879,"byte_end":2888,"line_start":99,"line_end":99,"column_start":34,"column_end":43,"is_primary":true,"text":[{"text":"        let line_len = line_text.len_chars();","highlight_start":34,"highlight_end":43}],"label":null,"suggested_replacement":"chars","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m: no method named `len_chars` found for struct `std::string::String` in the current scope\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/buffer/cursor.rs:99:34\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m99\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         let line_len = line_text.len_chars();\n   \u001b[1m\u001b[94m|\u001b[0m                                  \u001b[1m\u001b[91m^^^^^^^^^\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: there is a method `chars` with a similar name\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m99\u001b[0m \u001b[91m- \u001b[0m        let line_len = line_text.\u001b[91mlen_chars\u001b[0m();\n\u001b[1m\u001b[94m99\u001b[0m \u001b[92m+ \u001b[0m        let line_len = line_text.\u001b[92mchars\u001b[0m();\n   \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the method `min` exists for struct `buffer::cursor::Position`, but its trait bounds were not satisfied","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/buffer/cursor.rs","byte_start":4822,"byte_end":4825,"line_start":156,"line_end":156,"column_start":32,"column_end":35,"is_primary":true,"text":[{"text":"            let start = anchor.min(self.position);","highlight_start":32,"highlight_end":35}],"label":"method cannot be called on `buffer::cursor::Position` due to unsatisfied trait bounds","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/buffer/cursor.rs","byte_start":107,"byte_end":126,"line_start":4,"line_end":4,"column_start":1,"column_end":20,"is_primary":false,"text":[{"text":"pub struct Position {","highlight_start":1,"highlight_end":20}],"label":"method `min` not found for this struct because it doesn't satisfy `buffer::cursor::Position: Iterator` or `buffer::cursor::Position: Ord`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following trait bounds were not satisfied:\n`buffer::cursor::Position: Ord`\nwhich is required by `&buffer::cursor::Position: Ord`\n`buffer::cursor::Position: Ord`\nwhich is required by `&mut buffer::cursor::Position: Ord`\n`buffer::cursor::Position: Iterator`\nwhich is required by `&mut buffer::cursor::Position: Iterator`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"the trait `Iterator` must be implemented","code":null,"level":"note","spans":[{"file_name":"/rustc/01f6ddf7588f42ae2d7eb0a2f21d44e8e96674cf/library/core/src/iter/traits/iterator.rs","byte_start":1514,"byte_end":1532,"line_start":40,"line_end":40,"column_start":1,"column_end":19,"is_primary":true,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"consider annotating `buffer::cursor::Position` with `#[derive(Eq, Ord, PartialEq, PartialOrd)]`","code":null,"level":"help","spans":[{"file_name":"src/buffer/cursor.rs","byte_start":107,"byte_end":107,"line_start":4,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"pub struct Position {","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"#[derive(Eq, Ord, PartialEq, PartialOrd)]\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m: the method `min` exists for struct `buffer::cursor::Position`, but its trait bounds were not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/buffer/cursor.rs:156:32\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m4\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Position {\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m-------------------\u001b[0m \u001b[1m\u001b[94mmethod `min` not found for this struct because it doesn't satisfy `buffer::cursor::Position: Iterator` or `buffer::cursor::Position: Ord`\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m156\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             let start = anchor.min(self.position);\n    \u001b[1m\u001b[94m|\u001b[0m                                \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mmethod cannot be called on `buffer::cursor::Position` due to unsatisfied trait bounds\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the following trait bounds were not satisfied:\n            `buffer::cursor::Position: Ord`\n            which is required by `&buffer::cursor::Position: Ord`\n            `buffer::cursor::Position: Ord`\n            which is required by `&mut buffer::cursor::Position: Ord`\n            `buffer::cursor::Position: Iterator`\n            which is required by `&mut buffer::cursor::Position: Iterator`\n\u001b[1m\u001b[92mnote\u001b[0m: the trait `Iterator` must be implemented\n   \u001b[1m\u001b[94m--> \u001b[0m/rustc/01f6ddf7588f42ae2d7eb0a2f21d44e8e96674cf/library/core/src/iter/traits/iterator.rs:40:1\n\u001b[1m\u001b[96mhelp\u001b[0m: consider annotating `buffer::cursor::Position` with `#[derive(Eq, Ord, PartialEq, PartialOrd)]`\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m4\u001b[0m \u001b[92m+ #[derive(Eq, Ord, PartialEq, PartialOrd)]\u001b[0m\n  \u001b[1m\u001b[94m5\u001b[0m \u001b[1m\u001b[94m| \u001b[0mpub struct Position {\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the method `max` exists for struct `buffer::cursor::Position`, but its trait bounds were not satisfied","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/buffer/cursor.rs","byte_start":4871,"byte_end":4874,"line_start":157,"line_end":157,"column_start":30,"column_end":33,"is_primary":true,"text":[{"text":"            let end = anchor.max(self.position);","highlight_start":30,"highlight_end":33}],"label":"method cannot be called on `buffer::cursor::Position` due to unsatisfied trait bounds","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/buffer/cursor.rs","byte_start":107,"byte_end":126,"line_start":4,"line_end":4,"column_start":1,"column_end":20,"is_primary":false,"text":[{"text":"pub struct Position {","highlight_start":1,"highlight_end":20}],"label":"method `max` not found for this struct because it doesn't satisfy `buffer::cursor::Position: Iterator` or `buffer::cursor::Position: Ord`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following trait bounds were not satisfied:\n`buffer::cursor::Position: Ord`\nwhich is required by `&buffer::cursor::Position: Ord`\n`buffer::cursor::Position: Ord`\nwhich is required by `&mut buffer::cursor::Position: Ord`\n`buffer::cursor::Position: Iterator`\nwhich is required by `&mut buffer::cursor::Position: Iterator`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"the trait `Iterator` must be implemented","code":null,"level":"note","spans":[{"file_name":"/rustc/01f6ddf7588f42ae2d7eb0a2f21d44e8e96674cf/library/core/src/iter/traits/iterator.rs","byte_start":1514,"byte_end":1532,"line_start":40,"line_end":40,"column_start":1,"column_end":19,"is_primary":true,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"consider annotating `buffer::cursor::Position` with `#[derive(Eq, Ord, PartialEq, PartialOrd)]`","code":null,"level":"help","spans":[{"file_name":"src/buffer/cursor.rs","byte_start":107,"byte_end":107,"line_start":4,"line_end":4,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"pub struct Position {","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"#[derive(Eq, Ord, PartialEq, PartialOrd)]\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m: the method `max` exists for struct `buffer::cursor::Position`, but its trait bounds were not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/buffer/cursor.rs:157:30\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m4\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Position {\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m-------------------\u001b[0m \u001b[1m\u001b[94mmethod `max` not found for this struct because it doesn't satisfy `buffer::cursor::Position: Iterator` or `buffer::cursor::Position: Ord`\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m157\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             let end = anchor.max(self.position);\n    \u001b[1m\u001b[94m|\u001b[0m                              \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mmethod cannot be called on `buffer::cursor::Position` due to unsatisfied trait bounds\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the following trait bounds were not satisfied:\n            `buffer::cursor::Position: Ord`\n            which is required by `&buffer::cursor::Position: Ord`\n            `buffer::cursor::Position: Ord`\n            which is required by `&mut buffer::cursor::Position: Ord`\n            `buffer::cursor::Position: Iterator`\n            which is required by `&mut buffer::cursor::Position: Iterator`\n\u001b[1m\u001b[92mnote\u001b[0m: the trait `Iterator` must be implemented\n   \u001b[1m\u001b[94m--> \u001b[0m/rustc/01f6ddf7588f42ae2d7eb0a2f21d44e8e96674cf/library/core/src/iter/traits/iterator.rs:40:1\n\u001b[1m\u001b[96mhelp\u001b[0m: consider annotating `buffer::cursor::Position` with `#[derive(Eq, Ord, PartialEq, PartialOrd)]`\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m4\u001b[0m \u001b[92m+ #[derive(Eq, Ord, PartialEq, PartialOrd)]\u001b[0m\n  \u001b[1m\u001b[94m5\u001b[0m \u001b[1m\u001b[94m| \u001b[0mpub struct Position {\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `Settings: serde::de::DeserializeOwned` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/config/settings.rs","byte_start":1438,"byte_end":1463,"line_start":51,"line_end":51,"column_start":43,"column_end":68,"is_primary":true,"text":[{"text":"                    if let Ok(settings) = toml::from_str(&contents) {","highlight_start":43,"highlight_end":68}],"label":"unsatisfied trait bound","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the trait `for<'de> Deserialize<'de>` is not implemented for `Settings`","code":null,"level":"help","spans":[{"file_name":"src/config/settings.rs","byte_start":110,"byte_end":129,"line_start":5,"line_end":5,"column_start":1,"column_end":20,"is_primary":true,"text":[{"text":"pub struct Settings {","highlight_start":1,"highlight_end":20}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the following other types implement trait `Deserialize<'de>`:\n  &'a Path\n  &'a [u8]\n  &'a str\n  ()\n  (T,)\n  (T0, T1)\n  (T0, T1, T2)\n  (T0, T1, T2, T3)\nand 146 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `Settings` to implement `serde_core::de::DeserializeOwned`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `toml::from_str`","code":null,"level":"note","spans":[{"file_name":"/root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/toml-0.8.23/src/de.rs","byte_start":994,"byte_end":1002,"line_start":41,"line_end":41,"column_start":8,"column_end":16,"is_primary":false,"text":[{"text":"pub fn from_str<T>(s: &'_ str) -> Result<T, Error>","highlight_start":8,"highlight_end":16}],"label":"required by a bound in this function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/toml-0.8.23/src/de.rs","byte_start":1051,"byte_end":1078,"line_start":43,"line_end":43,"column_start":8,"column_end":35,"is_primary":true,"text":[{"text":"    T: serde::de::DeserializeOwned,","highlight_start":8,"highlight_end":35}],"label":"required by this bound in `from_str`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Settings: serde::de::DeserializeOwned` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/config/settings.rs:51:43\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m51\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                     if let Ok(settings) = toml::from_str(&contents) {\n   \u001b[1m\u001b[94m|\u001b[0m                                           \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91munsatisfied trait bound\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: the trait `for<'de> Deserialize<'de>` is not implemented for `Settings`\n  \u001b[1m\u001b[94m--> \u001b[0msrc/config/settings.rs:5:1\n   \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m5\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Settings {\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[96m^^^^^^^^^^^^^^^^^^^\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `Deserialize<'de>`:\n             &'a Path\n             &'a [u8]\n             &'a str\n             ()\n             (T,)\n             (T0, T1)\n             (T0, T1, T2)\n             (T0, T1, T2, T3)\n           and 146 others\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `Settings` to implement `serde_core::de::DeserializeOwned`\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `toml::from_str`\n  \u001b[1m\u001b[94m--> \u001b[0m/root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/toml-0.8.23/src/de.rs:43:8\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m41\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn from_str<T>(s: &'_ str) -> Result<T, Error>\n   \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[94m--------\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this function\u001b[0m\n\u001b[1m\u001b[94m42\u001b[0m \u001b[1m\u001b[94m|\u001b[0m where\n\u001b[1m\u001b[94m43\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     T: serde::de::DeserializeOwned,\n   \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `from_str`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `Settings: serde::Serialize` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/config/settings.rs","byte_start":1860,"byte_end":1864,"line_start":65,"line_end":65,"column_start":47,"column_end":51,"is_primary":true,"text":[{"text":"            let toml = toml::to_string_pretty(self).unwrap();","highlight_start":47,"highlight_end":51}],"label":"unsatisfied trait bound","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/config/settings.rs","byte_start":1837,"byte_end":1859,"line_start":65,"line_end":65,"column_start":24,"column_end":46,"is_primary":false,"text":[{"text":"            let toml = toml::to_string_pretty(self).unwrap();","highlight_start":24,"highlight_end":46}],"label":"required by a bound introduced by this call","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the trait `serde_core::ser::Serialize` is not implemented for `Settings`","code":null,"level":"help","spans":[{"file_name":"src/config/settings.rs","byte_start":110,"byte_end":129,"line_start":5,"line_end":5,"column_start":1,"column_end":20,"is_primary":true,"text":[{"text":"pub struct Settings {","highlight_start":1,"highlight_end":20}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"for local types consider adding `#[derive(serde::Serialize)]` to your `Settings` type","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for types from other crates check whether the crate offers a `serde` feature flag","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `serde_core::ser::Serialize`:\n  &'a T\n  &'a mut T\n  ()\n  (T,)\n  (T0, T1)\n  (T0, T1, T2)\n  (T0, T1, T2, T3)\n  (T0, T1, T2, T3, T4)\nand 133 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `to_string_pretty`","code":null,"level":"note","spans":[{"file_name":"/root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/toml-0.8.23/src/ser/mod.rs","byte_start":2172,"byte_end":2188,"line_start":76,"line_end":76,"column_start":8,"column_end":24,"is_primary":false,"text":[{"text":"pub fn to_string_pretty<T>(value: &T) -> Result<String, Error>","highlight_start":8,"highlight_end":24}],"label":"required by a bound in this function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/toml-0.8.23/src/ser/mod.rs","byte_start":2241,"byte_end":2262,"line_start":78,"line_end":78,"column_start":8,"column_end":29,"is_primary":true,"text":[{"text":"    T: serde::ser::Serialize + ?Sized,","highlight_start":8,"highlight_end":29}],"label":"required by this bound in `to_string_pretty`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Settings: serde::Serialize` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/config/settings.rs:65:47\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m65\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             let toml = toml::to_string_pretty(self).unwrap();\n   \u001b[1m\u001b[94m|\u001b[0m                        \u001b[1m\u001b[94m----------------------\u001b[0m \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91munsatisfied trait bound\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m                        \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m                        \u001b[1m\u001b[94mrequired by a bound introduced by this call\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: the trait `serde_core::ser::Serialize` is not implemented for `Settings`\n  \u001b[1m\u001b[94m--> \u001b[0msrc/config/settings.rs:5:1\n   \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m5\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Settings {\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[96m^^^^^^^^^^^^^^^^^^^\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: for local types consider adding `#[derive(serde::Serialize)]` to your `Settings` type\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: for types from other crates check whether the crate offers a `serde` feature flag\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `serde_core::ser::Serialize`:\n             &'a T\n             &'a mut T\n             ()\n             (T,)\n             (T0, T1)\n             (T0, T1, T2)\n             (T0, T1, T2, T3)\n             (T0, T1, T2, T3, T4)\n           and 133 others\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `to_string_pretty`\n  \u001b[1m\u001b[94m--> \u001b[0m/root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/toml-0.8.23/src/ser/mod.rs:78:8\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m76\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn to_string_pretty<T>(value: &T) -> Result<String, Error>\n   \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[94m----------------\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this function\u001b[0m\n\u001b[1m\u001b[94m77\u001b[0m \u001b[1m\u001b[94m|\u001b[0m where\n\u001b[1m\u001b[94m78\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     T: serde::ser::Serialize + ?Sized,\n   \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `to_string_pretty`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"src/syntax/highlight.rs","byte_start":494,"byte_end":504,"line_start":21,"line_end":21,"column_start":13,"column_end":23,"is_primary":true,"text":[{"text":"            extensions,","highlight_start":13,"highlight_end":23}],"label":"expected `Vec<String>`, found `Vec<&str>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected struct `Vec<std::string::String>`\n   found struct `Vec<&str>`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m: mismatched types\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/syntax/highlight.rs:21:13\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m21\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             extensions,\n   \u001b[1m\u001b[94m|\u001b[0m             \u001b[1m\u001b[91m^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mexpected `Vec<String>`, found `Vec<&str>`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: expected struct `Vec<\u001b[1m\u001b[35mstd::string::String\u001b[0m>`\n              found struct `Vec<\u001b[1m\u001b[35m&str\u001b[0m>`\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"src/syntax/highlight.rs","byte_start":970,"byte_end":978,"line_start":32,"line_end":32,"column_start":25,"column_end":33,"is_primary":true,"text":[{"text":"        self.keywords = keywords;","highlight_start":25,"highlight_end":33}],"label":"expected `Vec<String>`, found `Vec<&str>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/syntax/highlight.rs","byte_start":954,"byte_end":967,"line_start":32,"line_end":32,"column_start":9,"column_end":22,"is_primary":false,"text":[{"text":"        self.keywords = keywords;","highlight_start":9,"highlight_end":22}],"label":"expected due to the type of this binding","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected struct `Vec<std::string::String>`\n   found struct `Vec<&str>`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m: mismatched types\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/syntax/highlight.rs:32:25\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m32\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         self.keywords = keywords;\n   \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[94m-------------\u001b[0m   \u001b[1m\u001b[91m^^^^^^^^\u001b[0m \u001b[1m\u001b[91mexpected `Vec<String>`, found `Vec<&str>`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[94mexpected due to the type of this binding\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: expected struct `Vec<\u001b[1m\u001b[35mstd::string::String\u001b[0m>`\n              found struct `Vec<\u001b[1m\u001b[35m&str\u001b[0m>`\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"src/syntax/highlight.rs","byte_start":1081,"byte_end":1086,"line_start":37,"line_end":37,"column_start":22,"column_end":27,"is_primary":true,"text":[{"text":"        self.types = types;","highlight_start":22,"highlight_end":27}],"label":"expected `Vec<String>`, found `Vec<&str>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/syntax/highlight.rs","byte_start":1068,"byte_end":1078,"line_start":37,"line_end":37,"column_start":9,"column_end":19,"is_primary":false,"text":[{"text":"        self.types = types;","highlight_start":9,"highlight_end":19}],"label":"expected due to the type of this binding","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected struct `Vec<std::string::String>`\n   found struct `Vec<&str>`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m: mismatched types\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/syntax/highlight.rs:37:22\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m37\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         self.types = types;\n   \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[94m----------\u001b[0m   \u001b[1m\u001b[91m^^^^^\u001b[0m \u001b[1m\u001b[91mexpected `Vec<String>`, found `Vec<&str>`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[94mexpected due to the type of this binding\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: expected struct `Vec<\u001b[1m\u001b[35mstd::string::String\u001b[0m>`\n              found struct `Vec<\u001b[1m\u001b[35m&str\u001b[0m>`\n\n"}
{"$message_type":"diagnostic","message":"use of deprecated method `ratatui::prelude::Buffer::get_mut`: use `Buffer[(x, y)]` instead. To avoid panicking, use `Buffer::cell_mut((x, y))`. Both methods take `impl Into<Position>`.","code":{"code":"deprecated","explanation":null},"level":"warning","spans":[{"file_name":"src/ui/widgets.rs","byte_start":2225,"byte_end":2232,"line_start":79,"line_end":79,"column_start":29,"column_end":36,"is_primary":true,"text":[{"text":"                        buf.get_mut(inner.x + x as u16, inner.y + y)","highlight_start":29,"highlight_end":36}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(deprecated)]` on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: use of deprecated method `ratatui::prelude::Buffer::get_mut`: use `Buffer[(x, y)]` instead. To avoid panicking, use `Buffer::cell_mut((x, y))`. Both methods take `impl Into<Position>`.\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/ui/widgets.rs:79:29\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m79\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                         buf.get_mut(inner.x + x as u16, inner.y + y)\n   \u001b[1m\u001b[94m|\u001b[0m                             \u001b[1m\u001b[33m^^^^^^^\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: `#[warn(deprecated)]` on by default\n\n"}
{"$message_type":"diagnostic","message":"use of deprecated method `ratatui::prelude::Buffer::get_mut`: use `Buffer[(x, y)]` instead. To avoid panicking, use `Buffer::cell_mut((x, y))`. Both methods take `impl Into<Position>`.","code":{"code":"deprecated","explanation":null},"level":"warning","spans":[{"file_name":"src/ui/widgets.rs","byte_start":3342,"byte_end":3349,"line_start":102,"line_end":102,"column_start":25,"column_end":32,"is_primary":true,"text":[{"text":"                    buf.get_mut(col as u16, inner.y + y)","highlight_start":25,"highlight_end":32}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: use of deprecated method `ratatui::prelude::Buffer::get_mut`: use `Buffer[(x, y)]` instead. To avoid panicking, use `Buffer::cell_mut((x, y))`. Both methods take `impl Into<Position>`.\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/ui/widgets.rs:102:25\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m102\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                     buf.get_mut(col as u16, inner.y + y)\n    \u001b[1m\u001b[94m|\u001b[0m                         \u001b[1m\u001b[33m^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"use of deprecated method `ratatui::prelude::Buffer::get_mut`: use `Buffer[(x, y)]` instead. To avoid panicking, use `Buffer::cell_mut((x, y))`. Both methods take `impl Into<Position>`.","code":{"code":"deprecated","explanation":null},"level":"warning","spans":[{"file_name":"src/ui/widgets.rs","byte_start":4647,"byte_end":4654,"line_start":158,"line_end":158,"column_start":21,"column_end":28,"is_primary":true,"text":[{"text":"                buf.get_mut(area.x + x as u16, area.y)","highlight_start":21,"highlight_end":28}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: use of deprecated method `ratatui::prelude::Buffer::get_mut`: use `Buffer[(x, y)]` instead. To avoid panicking, use `Buffer::cell_mut((x, y))`. Both methods take `impl Into<Position>`.\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/ui/widgets.rs:158:21\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m158\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                 buf.get_mut(area.x + x as u16, area.y)\n    \u001b[1m\u001b[94m|\u001b[0m                     \u001b[1m\u001b[33m^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"use of deprecated method `ratatui::prelude::Buffer::get_mut`: use `Buffer[(x, y)]` instead. To avoid panicking, use `Buffer::cell_mut((x, y))`. Both methods take `impl Into<Position>`.","code":{"code":"deprecated","explanation":null},"level":"warning","spans":[{"file_name":"src/ui/widgets.rs","byte_start":5077,"byte_end":5084,"line_start":168,"line_end":168,"column_start":25,"column_end":32,"is_primary":true,"text":[{"text":"                    buf.get_mut(start + x as u16, area.y)","highlight_start":25,"highlight_end":32}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: use of deprecated method `ratatui::prelude::Buffer::get_mut`: use `Buffer[(x, y)]` instead. To avoid panicking, use `Buffer::cell_mut((x, y))`. Both methods take `impl Into<Position>`.\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/ui/widgets.rs:168:25\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m168\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                     buf.get_mut(start + x as u16, area.y)\n    \u001b[1m\u001b[94m|\u001b[0m                         \u001b[1m\u001b[33m^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"use of deprecated method `ratatui::prelude::Buffer::get_mut`: use `Buffer[(x, y)]` instead. To avoid panicking, use `Buffer::cell_mut((x, y))`. Both methods take `impl Into<Position>`.","code":{"code":"deprecated","explanation":null},"level":"warning","spans":[{"file_name":"src/ui/widgets.rs","byte_start":5367,"byte_end":5374,"line_start":176,"line_end":176,"column_start":17,"column_end":24,"is_primary":true,"text":[{"text":"            buf.get_mut(area.x + x as u16, area.y)","highlight_start":17,"highlight_end":24}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: use of deprecated method `ratatui::prelude::Buffer::get_mut`: use `Buffer[(x, y)]` instead. To avoid panicking, use `Buffer::cell_mut((x, y))`. Both methods take `impl Into<Position>`.\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/ui/widgets.rs:176:17\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m176\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             buf.get_mut(area.x + x as u16, area.y)\n    \u001b[1m\u001b[94m|\u001b[0m                 \u001b[1m\u001b[33m^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"use of deprecated method `ratatui::prelude::Buffer::get_mut`: use `Buffer[(x, y)]` instead. To avoid panicking, use `Buffer::cell_mut((x, y))`. Both methods take `impl Into<Position>`.","code":{"code":"deprecated","explanation":null},"level":"warning","spans":[{"file_name":"src/ui/widgets.rs","byte_start":6118,"byte_end":6125,"line_start":212,"line_end":212,"column_start":17,"column_end":24,"is_primary":true,"text":[{"text":"            buf.get_mut(area.x + x, area.y)","highlight_start":17,"highlight_end":24}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: use of deprecated method `ratatui::prelude::Buffer::get_mut`: use `Buffer[(x, y)]` instead. To avoid panicking, use `Buffer::cell_mut((x, y))`. Both methods take `impl Into<Position>`.\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/ui/widgets.rs:212:17\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m212\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             buf.get_mut(area.x + x, area.y)\n    \u001b[1m\u001b[94m|\u001b[0m                 \u001b[1m\u001b[33m^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"use of deprecated method `ratatui::prelude::Buffer::get_mut`: use `Buffer[(x, y)]` instead. To avoid panicking, use `Buffer::cell_mut((x, y))`. Both methods take `impl Into<Position>`.","code":{"code":"deprecated","explanation":null},"level":"warning","spans":[{"file_name":"src/ui/widgets.rs","byte_start":6646,"byte_end":6653,"line_start":227,"line_end":227,"column_start":21,"column_end":28,"is_primary":true,"text":[{"text":"                buf.get_mut(area.x + x as u16, area.y)","highlight_start":21,"highlight_end":28}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: use of deprecated method `ratatui::prelude::Buffer::get_mut`: use `Buffer[(x, y)]` instead. To avoid panicking, use `Buffer::cell_mut((x, y))`. Both methods take `impl Into<Position>`.\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/ui/widgets.rs:227:21\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m227\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                 buf.get_mut(area.x + x as u16, area.y)\n    \u001b[1m\u001b[94m|\u001b[0m                     \u001b[1m\u001b[33m^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"src/ui/layout.rs","byte_start":660,"byte_end":784,"line_start":30,"line_end":33,"column_start":9,"column_end":25,"is_primary":true,"text":[{"text":"        Layout::default()","highlight_start":9,"highlight_end":26},{"text":"            .direction(Direction::Vertical)","highlight_start":1,"highlight_end":44},{"text":"            .constraints(constraints)","highlight_start":1,"highlight_end":38},{"text":"            .split(area)","highlight_start":1,"highlight_end":25}],"label":"expected `Layout`, found `Rc<[Rect]>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/ui/layout.rs","byte_start":347,"byte_end":353,"line_start":17,"line_end":17,"column_start":45,"column_end":51,"is_primary":false,"text":[{"text":"    pub fn get_layout(&self, area: Rect) -> Layout {","highlight_start":45,"highlight_end":51}],"label":"expected `ratatui::prelude::Layout` because of return type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected struct `ratatui::prelude::Layout`\n   found struct `Rc<[Rect]>`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m: mismatched types\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/ui/layout.rs:30:9\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m17\u001b[0m \u001b[1m\u001b[94m|\u001b[0m       pub fn get_layout(&self, area: Rect) -> Layout {\n   \u001b[1m\u001b[94m|\u001b[0m                                               \u001b[1m\u001b[94m------\u001b[0m \u001b[1m\u001b[94mexpected `ratatui::prelude::Layout` because of return type\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m30\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m/\u001b[0m         Layout::default()\n\u001b[1m\u001b[94m31\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m             .direction(Direction::Vertical)\n\u001b[1m\u001b[94m32\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m             .constraints(constraints)\n\u001b[1m\u001b[94m33\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m             .split(area)\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|________________________^\u001b[0m \u001b[1m\u001b[91mexpected `Layout`, found `Rc<[Rect]>`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: expected struct `\u001b[1m\u001b[35mratatui::prelude::Layout\u001b[0m`\n              found struct `\u001b[1m\u001b[35mRc<[Rect]>\u001b[0m`\n\n"}
{"$message_type":"diagnostic","message":"cannot index into a value of type `ratatui::prelude::Layout`","code":{"code":"E0608","explanation":"Attempted to index a value whose type doesn't implement the\n`std::ops::Index` trait.\n\nErroneous code example:\n\n```compile_fail,E0608\n0u8[2]; // error: cannot index into a value of type `u8`\n```\n\nOnly values with types that implement the `std::ops::Index` trait\ncan be indexed with square brackets. Example:\n\n```\nlet v: Vec<u8> = vec![0, 1, 2, 3];\n\n// The `Vec` type implements the `Index` trait so you can do:\nprintln!(\"{}\", v[2]);\n```\n\nTuples and structs are indexed with dot (`.`), not with brackets (`[]`),\nand tuple element names are their positions:\n```ignore(pseudo code)\n// this (pseudo code) expression is true for any tuple:\ntuple == (tuple.0, tuple.1, ...)\n```\n"},"level":"error","spans":[{"file_name":"src/ui/layout.rs","byte_start":958,"byte_end":961,"line_start":39,"line_end":39,"column_start":19,"column_end":22,"is_primary":true,"text":[{"text":"            layout[1]","highlight_start":19,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0608]\u001b[0m\u001b[1m: cannot index into a value of type `ratatui::prelude::Layout`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/ui/layout.rs:39:19\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m39\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             layout[1]\n   \u001b[1m\u001b[94m|\u001b[0m                   \u001b[1m\u001b[91m^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot index into a value of type `ratatui::prelude::Layout`","code":{"code":"E0608","explanation":"Attempted to index a value whose type doesn't implement the\n`std::ops::Index` trait.\n\nErroneous code example:\n\n```compile_fail,E0608\n0u8[2]; // error: cannot index into a value of type `u8`\n```\n\nOnly values with types that implement the `std::ops::Index` trait\ncan be indexed with square brackets. Example:\n\n```\nlet v: Vec<u8> = vec![0, 1, 2, 3];\n\n// The `Vec` type implements the `Index` trait so you can do:\nprintln!(\"{}\", v[2]);\n```\n\nTuples and structs are indexed with dot (`.`), not with brackets (`[]`),\nand tuple element names are their positions:\n```ignore(pseudo code)\n// this (pseudo code) expression is true for any tuple:\ntuple == (tuple.0, tuple.1, ...)\n```\n"},"level":"error","spans":[{"file_name":"src/ui/layout.rs","byte_start":1035,"byte_end":1038,"line_start":41,"line_end":41,"column_start":19,"column_end":22,"is_primary":true,"text":[{"text":"            layout[0]","highlight_start":19,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0608]\u001b[0m\u001b[1m: cannot index into a value of type `ratatui::prelude::Layout`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/ui/layout.rs:41:19\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m41\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             layout[0]\n   \u001b[1m\u001b[94m|\u001b[0m                   \u001b[1m\u001b[91m^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot index into a value of type `ratatui::prelude::Layout`","code":{"code":"E0608","explanation":"Attempted to index a value whose type doesn't implement the\n`std::ops::Index` trait.\n\nErroneous code example:\n\n```compile_fail,E0608\n0u8[2]; // error: cannot index into a value of type `u8`\n```\n\nOnly values with types that implement the `std::ops::Index` trait\ncan be indexed with square brackets. Example:\n\n```\nlet v: Vec<u8> = vec![0, 1, 2, 3];\n\n// The `Vec` type implements the `Index` trait so you can do:\nprintln!(\"{}\", v[2]);\n```\n\nTuples and structs are indexed with dot (`.`), not with brackets (`[]`),\nand tuple element names are their positions:\n```ignore(pseudo code)\n// this (pseudo code) expression is true for any tuple:\ntuple == (tuple.0, tuple.1, ...)\n```\n"},"level":"error","spans":[{"file_name":"src/ui/layout.rs","byte_start":1074,"byte_end":1077,"line_start":43,"line_end":43,"column_start":19,"column_end":22,"is_primary":true,"text":[{"text":"            layout[0]","highlight_start":19,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0608]\u001b[0m\u001b[1m: cannot index into a value of type `ratatui::prelude::Layout`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/ui/layout.rs:43:19\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m43\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             layout[0]\n   \u001b[1m\u001b[94m|\u001b[0m                   \u001b[1m\u001b[91m^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot index into a value of type `ratatui::prelude::Layout`","code":{"code":"E0608","explanation":"Attempted to index a value whose type doesn't implement the\n`std::ops::Index` trait.\n\nErroneous code example:\n\n```compile_fail,E0608\n0u8[2]; // error: cannot index into a value of type `u8`\n```\n\nOnly values with types that implement the `std::ops::Index` trait\ncan be indexed with square brackets. Example:\n\n```\nlet v: Vec<u8> = vec![0, 1, 2, 3];\n\n// The `Vec` type implements the `Index` trait so you can do:\nprintln!(\"{}\", v[2]);\n```\n\nTuples and structs are indexed with dot (`.`), not with brackets (`[]`),\nand tuple element names are their positions:\n```ignore(pseudo code)\n// this (pseudo code) expression is true for any tuple:\ntuple == (tuple.0, tuple.1, ...)\n```\n"},"level":"error","spans":[{"file_name":"src/ui/layout.rs","byte_start":1227,"byte_end":1230,"line_start":49,"line_end":49,"column_start":39,"column_end":42,"is_primary":true,"text":[{"text":"            Some(self.get_layout(area)[0])","highlight_start":39,"highlight_end":42}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0608]\u001b[0m\u001b[1m: cannot index into a value of type `ratatui::prelude::Layout`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/ui/layout.rs:49:39\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m49\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             Some(self.get_layout(area)[0])\n   \u001b[1m\u001b[94m|\u001b[0m                                       \u001b[1m\u001b[91m^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no method named `len` found for struct `ratatui::prelude::Layout` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/ui/layout.rs","byte_start":1452,"byte_end":1455,"line_start":58,"line_end":58,"column_start":32,"column_end":35,"is_primary":true,"text":[{"text":"            Some(layout[layout.len() - 1])","highlight_start":32,"highlight_end":35}],"label":"method not found in `ratatui::prelude::Layout`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m: no method named `len` found for struct `ratatui::prelude::Layout` in the current scope\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/ui/layout.rs:58:32\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m58\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             Some(layout[layout.len() - 1])\n   \u001b[1m\u001b[94m|\u001b[0m                                \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mmethod not found in `ratatui::prelude::Layout`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"method `clamp_col` is private","code":{"code":"E0624","explanation":"A private item was used outside of its scope.\n\nErroneous code example:\n\n```compile_fail,E0624\nmod inner {\n    pub struct Foo;\n\n    impl Foo {\n        fn method(&self) {}\n    }\n}\n\nlet foo = inner::Foo;\nfoo.method(); // error: method `method` is private\n```\n\nTwo possibilities are available to solve this issue:\n\n1. Only use the item in the scope it has been defined:\n\n```\nmod inner {\n    pub struct Foo;\n\n    impl Foo {\n        fn method(&self) {}\n    }\n\n    pub fn call_method(foo: &Foo) { // We create a public function.\n        foo.method(); // Which calls the item.\n    }\n}\n\nlet foo = inner::Foo;\ninner::call_method(&foo); // And since the function is public, we can call the\n                          // method through it.\n```\n\n2. Make the item public:\n\n```\nmod inner {\n    pub struct Foo;\n\n    impl Foo {\n        pub fn method(&self) {} // It's now public.\n    }\n}\n\nlet foo = inner::Foo;\nfoo.method(); // Ok!\n```\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":3259,"byte_end":3268,"line_start":121,"line_end":121,"column_start":32,"column_end":41,"is_primary":true,"text":[{"text":"                    tab.cursor.clamp_col(&tab.buffer);","highlight_start":32,"highlight_end":41}],"label":"private method","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/buffer/cursor.rs","byte_start":3979,"byte_end":4026,"line_start":128,"line_end":128,"column_start":5,"column_end":52,"is_primary":false,"text":[{"text":"    fn clamp_col(&mut self, buffer: &super::Buffer) {","highlight_start":5,"highlight_end":52}],"label":"private method defined here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0624]\u001b[0m\u001b[1m: method `clamp_col` is private\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:121:32\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m121\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                     tab.cursor.clamp_col(&tab.buffer);\n    \u001b[1m\u001b[94m|\u001b[0m                                \u001b[1m\u001b[91m^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mprivate method\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m::: \u001b[0msrc/buffer/cursor.rs:128:5\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m128\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     fn clamp_col(&mut self, buffer: &super::Buffer) {\n    \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[94m-----------------------------------------------\u001b[0m \u001b[1m\u001b[94mprivate method defined here\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no method named `execute` found for mutable reference `&mut CrosstermBackend<Stdout>` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":15412,"byte_end":15419,"line_start":434,"line_end":434,"column_start":28,"column_end":35,"is_primary":true,"text":[{"text":"    terminal.backend_mut().execute(LeaveAlternateScreen)?;","highlight_start":28,"highlight_end":35}],"label":"method not found in `&mut CrosstermBackend<Stdout>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"items from traits can only be used if the trait is in scope","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the following traits which provide `execute` are implemented but not in scope; perhaps you want to import one of them","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[],"label":null,"suggested_replacement":"use crossterm::ExecutableCommand;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"src/main.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[],"label":null,"suggested_replacement":"use ratatui::crossterm::ExecutableCommand;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m: no method named `execute` found for mutable reference `&mut CrosstermBackend<Stdout>` in the current scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:434:28\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m434\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     terminal.backend_mut().execute(LeaveAlternateScreen)?;\n    \u001b[1m\u001b[94m|\u001b[0m                            \u001b[1m\u001b[91m^^^^^^^\u001b[0m \u001b[1m\u001b[91mmethod not found in `&mut CrosstermBackend<Stdout>`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: items from traits can only be used if the trait is in scope\n\u001b[1m\u001b[96mhelp\u001b[0m: the following traits which provide `execute` are implemented but not in scope; perhaps you want to import one of them\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m1\u001b[0m \u001b[92m+ use crossterm::ExecutableCommand;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m1\u001b[0m \u001b[92m+ use ratatui::crossterm::ExecutableCommand;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no method named `execute` found for mutable reference `&mut CrosstermBackend<Stdout>` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":15471,"byte_end":15478,"line_start":435,"line_end":435,"column_start":28,"column_end":35,"is_primary":true,"text":[{"text":"    terminal.backend_mut().execute(DisableMouseCapture)?;","highlight_start":28,"highlight_end":35}],"label":"method not found in `&mut CrosstermBackend<Stdout>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"items from traits can only be used if the trait is in scope","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the following traits which provide `execute` are implemented but not in scope; perhaps you want to import one of them","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[],"label":null,"suggested_replacement":"use crossterm::ExecutableCommand;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"src/main.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[],"label":null,"suggested_replacement":"use ratatui::crossterm::ExecutableCommand;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m: no method named `execute` found for mutable reference `&mut CrosstermBackend<Stdout>` in the current scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:435:28\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m435\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     terminal.backend_mut().execute(DisableMouseCapture)?;\n    \u001b[1m\u001b[94m|\u001b[0m                            \u001b[1m\u001b[91m^^^^^^^\u001b[0m \u001b[1m\u001b[91mmethod not found in `&mut CrosstermBackend<Stdout>`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: items from traits can only be used if the trait is in scope\n\u001b[1m\u001b[96mhelp\u001b[0m: the following traits which provide `execute` are implemented but not in scope; perhaps you want to import one of them\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m1\u001b[0m \u001b[92m+ use crossterm::ExecutableCommand;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m1\u001b[0m \u001b[92m+ use ratatui::crossterm::ExecutableCommand;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no method named `execute` found for struct `Stdout` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":15620,"byte_end":15627,"line_start":442,"line_end":442,"column_start":18,"column_end":25,"is_primary":true,"text":[{"text":"        stdout().execute(LeaveAlternateScreen)?;","highlight_start":18,"highlight_end":25}],"label":"method not found in `Stdout`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"items from traits can only be used if the trait is in scope","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the following traits which provide `execute` are implemented but not in scope; perhaps you want to import one of them","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[],"label":null,"suggested_replacement":"use crossterm::ExecutableCommand;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"src/main.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[],"label":null,"suggested_replacement":"use ratatui::crossterm::ExecutableCommand;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m: no method named `execute` found for struct `Stdout` in the current scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:442:18\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m442\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         stdout().execute(LeaveAlternateScreen)?;\n    \u001b[1m\u001b[94m|\u001b[0m                  \u001b[1m\u001b[91m^^^^^^^\u001b[0m \u001b[1m\u001b[91mmethod not found in `Stdout`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: items from traits can only be used if the trait is in scope\n\u001b[1m\u001b[96mhelp\u001b[0m: the following traits which provide `execute` are implemented but not in scope; perhaps you want to import one of them\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m1\u001b[0m \u001b[92m+ use crossterm::ExecutableCommand;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m1\u001b[0m \u001b[92m+ use ratatui::crossterm::ExecutableCommand;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unreachable pattern","code":{"code":"unreachable_patterns","explanation":null},"level":"warning","spans":[{"file_name":"src/buffer/buffer.rs","byte_start":3510,"byte_end":3517,"line_start":138,"line_end":138,"column_start":9,"column_end":16,"is_primary":true,"text":[{"text":"        \"scala\" => \"scala\",","highlight_start":9,"highlight_end":16}],"label":"no value can reach this","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/buffer/buffer.rs","byte_start":3098,"byte_end":3105,"line_start":124,"line_end":124,"column_start":9,"column_end":16,"is_primary":false,"text":[{"text":"        \"scala\" => \"scala\",","highlight_start":9,"highlight_end":16}],"label":"matches all the relevant values","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(unreachable_patterns)]` (part of `#[warn(unused)]`) on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unreachable pattern\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/buffer/buffer.rs:138:9\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m124\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         \"scala\" => \"scala\",\n    \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[94m-------\u001b[0m \u001b[1m\u001b[94mmatches all the relevant values\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m138\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         \"scala\" => \"scala\",\n    \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[33m^^^^^^^\u001b[0m \u001b[1m\u001b[33mno value can reach this\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: `#[warn(unreachable_patterns)]` (part of `#[warn(unused)]`) on by default\n\n"}
{"$message_type":"diagnostic","message":"unreachable pattern","code":{"code":"unreachable_patterns","explanation":null},"level":"warning","spans":[{"file_name":"src/syntax/highlight.rs","byte_start":8642,"byte_end":8648,"line_start":211,"line_end":211,"column_start":61,"column_end":67,"is_primary":true,"text":[{"text":"            \"python\" | \"ruby\" | \"shell\" | \"bash\" | \"yaml\" | \"ruby\" => Some(\"#\"),","highlight_start":61,"highlight_end":67}],"label":"no value can reach this","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/syntax/highlight.rs","byte_start":8605,"byte_end":8611,"line_start":211,"line_end":211,"column_start":24,"column_end":30,"is_primary":false,"text":[{"text":"            \"python\" | \"ruby\" | \"shell\" | \"bash\" | \"yaml\" | \"ruby\" => Some(\"#\"),","highlight_start":24,"highlight_end":30}],"label":"matches all the relevant values","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unreachable pattern\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/syntax/highlight.rs:211:61\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m211\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             \"python\" | \"ruby\" | \"shell\" | \"bash\" | \"yaml\" | \"ruby\" => Some(\"#\"),\n    \u001b[1m\u001b[94m|\u001b[0m                        \u001b[1m\u001b[94m------\u001b[0m                               \u001b[1m\u001b[33m^^^^^^\u001b[0m \u001b[1m\u001b[33mno value can reach this\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                        \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                        \u001b[1m\u001b[94mmatches all the relevant values\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"borrow of moved value: `block`","code":{"code":"E0382","explanation":"A variable was used after its contents have been moved elsewhere.\n\nErroneous code example:\n\n```compile_fail,E0382\nstruct MyStruct { s: u32 }\n\nfn main() {\n    let mut x = MyStruct{ s: 5u32 };\n    let y = x;\n    x.s = 6;\n    println!(\"{}\", x.s);\n}\n```\n\nSince `MyStruct` is a type that is not marked `Copy`, the data gets moved out\nof `x` when we set `y`. This is fundamental to Rust's ownership system: outside\nof workarounds like `Rc`, a value cannot be owned by more than one variable.\n\nSometimes we don't need to move the value. Using a reference, we can let another\nfunction borrow the value without changing its ownership. In the example below,\nwe don't actually have to move our string to `calculate_length`, we can give it\na reference to it with `&` instead.\n\n```\nfn main() {\n    let s1 = String::from(\"hello\");\n\n    let len = calculate_length(&s1);\n\n    println!(\"The length of '{}' is {}.\", s1, len);\n}\n\nfn calculate_length(s: &String) -> usize {\n    s.len()\n}\n```\n\nA mutable reference can be created with `&mut`.\n\nSometimes we don't want a reference, but a duplicate. All types marked `Clone`\ncan be duplicated by calling `.clone()`. Subsequent changes to a clone do not\naffect the original variable.\n\nMost types in the standard library are marked `Clone`. The example below\ndemonstrates using `clone()` on a string. `s1` is first set to \"many\", and then\ncopied to `s2`. Then the first character of `s1` is removed, without affecting\n`s2`. \"any many\" is printed to the console.\n\n```\nfn main() {\n    let mut s1 = String::from(\"many\");\n    let s2 = s1.clone();\n    s1.remove(0);\n    println!(\"{} {}\", s1, s2);\n}\n```\n\nIf we control the definition of a type, we can implement `Clone` on it ourselves\nwith `#[derive(Clone)]`.\n\nSome types have no ownership semantics at all and are trivial to duplicate. An\nexample is `i32` and the other number types. We don't have to call `.clone()` to\nclone them, because they are marked `Copy` in addition to `Clone`. Implicit\ncloning is more convenient in this case. We can mark our own types `Copy` if\nall their members also are marked `Copy`.\n\nIn the example below, we implement a `Point` type. Because it only stores two\nintegers, we opt-out of ownership semantics with `Copy`. Then we can\n`let p2 = p1` without `p1` being moved.\n\n```\n#[derive(Copy, Clone)]\nstruct Point { x: i32, y: i32 }\n\nfn main() {\n    let mut p1 = Point{ x: -1, y: 2 };\n    let p2 = p1;\n    p1.x = 1;\n    println!(\"p1: {}, {}\", p1.x, p1.y);\n    println!(\"p2: {}, {}\", p2.x, p2.y);\n}\n```\n\nAlternatively, if we don't control the struct's definition, or mutable shared\nownership is truly required, we can use `Rc` and `RefCell`:\n\n```\nuse std::cell::RefCell;\nuse std::rc::Rc;\n\nstruct MyStruct { s: u32 }\n\nfn main() {\n    let mut x = Rc::new(RefCell::new(MyStruct{ s: 5u32 }));\n    let y = x.clone();\n    x.borrow_mut().s = 6;\n    println!(\"{}\", x.borrow().s);\n}\n```\n\nWith this approach, x and y share ownership of the data via the `Rc` (reference\ncount type). `RefCell` essentially performs runtime borrow checking: ensuring\nthat at most one writer or multiple readers can access the data at any one time.\n\nIf you wish to learn more about ownership in Rust, start with the\n[Understanding Ownership][understanding-ownership] chapter in the Book.\n\n[understanding-ownership]: https://doc.rust-lang.org/book/ch04-00-understanding-ownership.html\n"},"level":"error","spans":[{"file_name":"src/ui/widgets.rs","byte_start":876,"byte_end":893,"line_start":41,"line_end":41,"column_start":15,"column_end":32,"is_primary":false,"text":[{"text":"        block.render(area, buf);","highlight_start":15,"highlight_end":32}],"label":"`block` moved due to this method call","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/ui/widgets.rs","byte_start":924,"byte_end":929,"line_start":43,"line_end":43,"column_start":21,"column_end":26,"is_primary":true,"text":[{"text":"        let inner = block.inner(area);","highlight_start":21,"highlight_end":26}],"label":"value borrowed here after move","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/ui/widgets.rs","byte_start":758,"byte_end":763,"line_start":38,"line_end":38,"column_start":13,"column_end":18,"is_primary":false,"text":[{"text":"        let block = Block::default()","highlight_start":13,"highlight_end":18}],"label":"move occurs because `block` has type `ratatui::widgets::Block<'_>`, which does not implement the `Copy` trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`ratatui::prelude::Widget::render` takes ownership of the receiver `self`, which moves `block`","code":null,"level":"note","spans":[{"file_name":"/root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/ratatui-core-0.1.0/src/widgets/widget.rs","byte_start":3027,"byte_end":3031,"line_start":73,"line_end":73,"column_start":15,"column_end":19,"is_primary":true,"text":[{"text":"    fn render(self, area: Rect, buf: &mut Buffer)","highlight_start":15,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"you can `clone` the value and consume it, but this might not be your desired behavior","code":null,"level":"help","spans":[{"file_name":"src/ui/widgets.rs","byte_start":875,"byte_end":875,"line_start":41,"line_end":41,"column_start":14,"column_end":14,"is_primary":true,"text":[{"text":"        block.render(area, buf);","highlight_start":14,"highlight_end":14}],"label":null,"suggested_replacement":".clone()","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0382]\u001b[0m\u001b[1m: borrow of moved value: `block`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/ui/widgets.rs:43:21\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m38\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         let block = Block::default()\n   \u001b[1m\u001b[94m|\u001b[0m             \u001b[1m\u001b[94m-----\u001b[0m \u001b[1m\u001b[94mmove occurs because `block` has type `ratatui::widgets::Block<'_>`, which does not implement the `Copy` trait\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m41\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         block.render(area, buf);\n   \u001b[1m\u001b[94m|\u001b[0m               \u001b[1m\u001b[94m-----------------\u001b[0m \u001b[1m\u001b[94m`block` moved due to this method call\u001b[0m\n\u001b[1m\u001b[94m42\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         \n\u001b[1m\u001b[94m43\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         let inner = block.inner(area);\n   \u001b[1m\u001b[94m|\u001b[0m                     \u001b[1m\u001b[91m^^^^^\u001b[0m \u001b[1m\u001b[91mvalue borrowed here after move\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: `ratatui::prelude::Widget::render` takes ownership of the receiver `self`, which moves `block`\n  \u001b[1m\u001b[94m--> \u001b[0m/root/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/ratatui-core-0.1.0/src/widgets/widget.rs:73:15\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m73\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     fn render(self, area: Rect, buf: &mut Buffer)\n   \u001b[1m\u001b[94m|\u001b[0m               \u001b[1m\u001b[92m^^^^\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: you can `clone` the value and consume it, but this might not be your desired behavior\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m41\u001b[0m \u001b[1m\u001b[94m| \u001b[0m        block\u001b[92m.clone()\u001b[0m.render(area, buf);\n   \u001b[1m\u001b[94m|\u001b[0m              \u001b[92m++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot assign to `self.quit_requested` because it is borrowed","code":{"code":"E0506","explanation":"An attempt was made to assign to a borrowed value.\n\nErroneous code example:\n\n```compile_fail,E0506\nstruct FancyNum {\n    num: u8,\n}\n\nlet mut fancy_num = FancyNum { num: 5 };\nlet fancy_ref = &fancy_num;\nfancy_num = FancyNum { num: 6 };\n// error: cannot assign to `fancy_num` because it is borrowed\n\nprintln!(\"Num: {}, Ref: {}\", fancy_num.num, fancy_ref.num);\n```\n\nBecause `fancy_ref` still holds a reference to `fancy_num`, `fancy_num` can't\nbe assigned to a new value as it would invalidate the reference.\n\nAlternatively, we can move out of `fancy_num` into a second `fancy_num`:\n\n```\nstruct FancyNum {\n    num: u8,\n}\n\nlet mut fancy_num = FancyNum { num: 5 };\nlet moved_num = fancy_num;\nfancy_num = FancyNum { num: 6 };\n\nprintln!(\"Num: {}, Moved num: {}\", fancy_num.num, moved_num.num);\n```\n\nIf the value has to be borrowed, try limiting the lifetime of the borrow using\na scoped block:\n\n```\nstruct FancyNum {\n    num: u8,\n}\n\nlet mut fancy_num = FancyNum { num: 5 };\n\n{\n    let fancy_ref = &fancy_num;\n    println!(\"Ref: {}\", fancy_ref.num);\n}\n\n// Works because `fancy_ref` is no longer in scope\nfancy_num = FancyNum { num: 6 };\nprintln!(\"Num: {}\", fancy_num.num);\n```\n\nOr by moving the reference into a function:\n\n```\nstruct FancyNum {\n    num: u8,\n}\n\nfn print_fancy_ref(fancy_ref: &FancyNum){\n    println!(\"Ref: {}\", fancy_ref.num);\n}\n\nlet mut fancy_num = FancyNum { num: 5 };\n\nprint_fancy_ref(&fancy_num);\n\n// Works because function borrow has ended\nfancy_num = FancyNum { num: 6 };\nprintln!(\"Num: {}\", fancy_num.num);\n```\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":3753,"byte_end":3757,"line_start":136,"line_end":136,"column_start":19,"column_end":23,"is_primary":false,"text":[{"text":"        let tab = self.active_tab();","highlight_start":19,"highlight_end":23}],"label":"`self.quit_requested` is borrowed here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":3852,"byte_end":3878,"line_start":140,"line_end":140,"column_start":17,"column_end":43,"is_primary":true,"text":[{"text":"                self.quit_requested = true;","highlight_start":17,"highlight_end":43}],"label":"`self.quit_requested` is assigned to here but it was already borrowed","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":11901,"byte_end":11925,"line_start":330,"line_end":330,"column_start":12,"column_end":36,"is_primary":false,"text":[{"text":"        if tab.cursor.position.line < tab.scroll_offset {","highlight_start":12,"highlight_end":36}],"label":"borrow later used here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0506]\u001b[0m\u001b[1m: cannot assign to `self.quit_requested` because it is borrowed\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:140:17\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m136\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         let tab = self.active_tab();\n    \u001b[1m\u001b[94m|\u001b[0m                   \u001b[1m\u001b[94m----\u001b[0m \u001b[1m\u001b[94m`self.quit_requested` is borrowed here\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m140\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                 self.quit_requested = true;\n    \u001b[1m\u001b[94m|\u001b[0m                 \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91m`self.quit_requested` is assigned to here but it was already borrowed\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m330\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         if tab.cursor.position.line < tab.scroll_offset {\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[94m------------------------\u001b[0m \u001b[1m\u001b[94mborrow later used here\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot borrow `self.tabs` as mutable more than once at a time","code":{"code":"E0499","explanation":"A variable was borrowed as mutable more than once.\n\nErroneous code example:\n\n```compile_fail,E0499\nlet mut i = 0;\nlet mut x = &mut i;\nlet mut a = &mut i;\nx;\n// error: cannot borrow `i` as mutable more than once at a time\n```\n\nPlease note that in Rust, you can either have many immutable references, or one\nmutable reference. For more details you may want to read the\n[References & Borrowing][references-and-borrowing] section of the Book.\n\n[references-and-borrowing]: https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html\n\nExample:\n\n```\nlet mut i = 0;\nlet mut x = &mut i; // ok!\n\n// or:\nlet mut i = 0;\nlet a = &i; // ok!\nlet b = &i; // still ok!\nlet c = &i; // still ok!\nb;\na;\n```\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":3753,"byte_end":3757,"line_start":136,"line_end":136,"column_start":19,"column_end":23,"is_primary":false,"text":[{"text":"        let tab = self.active_tab();","highlight_start":19,"highlight_end":23}],"label":"first mutable borrow occurs here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":4103,"byte_end":4112,"line_start":148,"line_end":148,"column_start":17,"column_end":26,"is_primary":true,"text":[{"text":"                self.tabs.push(Tab::new());","highlight_start":17,"highlight_end":26}],"label":"second mutable borrow occurs here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":11901,"byte_end":11925,"line_start":330,"line_end":330,"column_start":12,"column_end":36,"is_primary":false,"text":[{"text":"        if tab.cursor.position.line < tab.scroll_offset {","highlight_start":12,"highlight_end":36}],"label":"first borrow later used here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0499]\u001b[0m\u001b[1m: cannot borrow `self.tabs` as mutable more than once at a time\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:148:17\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m136\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         let tab = self.active_tab();\n    \u001b[1m\u001b[94m|\u001b[0m                   \u001b[1m\u001b[94m----\u001b[0m \u001b[1m\u001b[94mfirst mutable borrow occurs here\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m148\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                 self.tabs.push(Tab::new());\n    \u001b[1m\u001b[94m|\u001b[0m                 \u001b[1m\u001b[91m^^^^^^^^^\u001b[0m \u001b[1m\u001b[91msecond mutable borrow occurs here\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m330\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         if tab.cursor.position.line < tab.scroll_offset {\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[94m------------------------\u001b[0m \u001b[1m\u001b[94mfirst borrow later used here\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot assign to `self.active_tab` because it is borrowed","code":{"code":"E0506","explanation":"An attempt was made to assign to a borrowed value.\n\nErroneous code example:\n\n```compile_fail,E0506\nstruct FancyNum {\n    num: u8,\n}\n\nlet mut fancy_num = FancyNum { num: 5 };\nlet fancy_ref = &fancy_num;\nfancy_num = FancyNum { num: 6 };\n// error: cannot assign to `fancy_num` because it is borrowed\n\nprintln!(\"Num: {}, Ref: {}\", fancy_num.num, fancy_ref.num);\n```\n\nBecause `fancy_ref` still holds a reference to `fancy_num`, `fancy_num` can't\nbe assigned to a new value as it would invalidate the reference.\n\nAlternatively, we can move out of `fancy_num` into a second `fancy_num`:\n\n```\nstruct FancyNum {\n    num: u8,\n}\n\nlet mut fancy_num = FancyNum { num: 5 };\nlet moved_num = fancy_num;\nfancy_num = FancyNum { num: 6 };\n\nprintln!(\"Num: {}, Moved num: {}\", fancy_num.num, moved_num.num);\n```\n\nIf the value has to be borrowed, try limiting the lifetime of the borrow using\na scoped block:\n\n```\nstruct FancyNum {\n    num: u8,\n}\n\nlet mut fancy_num = FancyNum { num: 5 };\n\n{\n    let fancy_ref = &fancy_num;\n    println!(\"Ref: {}\", fancy_ref.num);\n}\n\n// Works because `fancy_ref` is no longer in scope\nfancy_num = FancyNum { num: 6 };\nprintln!(\"Num: {}\", fancy_num.num);\n```\n\nOr by moving the reference into a function:\n\n```\nstruct FancyNum {\n    num: u8,\n}\n\nfn print_fancy_ref(fancy_ref: &FancyNum){\n    println!(\"Ref: {}\", fancy_ref.num);\n}\n\nlet mut fancy_num = FancyNum { num: 5 };\n\nprint_fancy_ref(&fancy_num);\n\n// Works because function borrow has ended\nfancy_num = FancyNum { num: 6 };\nprintln!(\"Num: {}\", fancy_num.num);\n```\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":3753,"byte_end":3757,"line_start":136,"line_end":136,"column_start":19,"column_end":23,"is_primary":false,"text":[{"text":"        let tab = self.active_tab();","highlight_start":19,"highlight_end":23}],"label":"`self.active_tab` is borrowed here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":4147,"byte_end":4184,"line_start":149,"line_end":149,"column_start":17,"column_end":54,"is_primary":true,"text":[{"text":"                self.active_tab = self.tabs.len() - 1;","highlight_start":17,"highlight_end":54}],"label":"`self.active_tab` is assigned to here but it was already borrowed","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":11901,"byte_end":11925,"line_start":330,"line_end":330,"column_start":12,"column_end":36,"is_primary":false,"text":[{"text":"        if tab.cursor.position.line < tab.scroll_offset {","highlight_start":12,"highlight_end":36}],"label":"borrow later used here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0506]\u001b[0m\u001b[1m: cannot assign to `self.active_tab` because it is borrowed\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:149:17\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m136\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         let tab = self.active_tab();\n    \u001b[1m\u001b[94m|\u001b[0m                   \u001b[1m\u001b[94m----\u001b[0m \u001b[1m\u001b[94m`self.active_tab` is borrowed here\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m149\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                 self.active_tab = self.tabs.len() - 1;\n    \u001b[1m\u001b[94m|\u001b[0m                 \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91m`self.active_tab` is assigned to here but it was already borrowed\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m330\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         if tab.cursor.position.line < tab.scroll_offset {\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[94m------------------------\u001b[0m \u001b[1m\u001b[94mborrow later used here\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot borrow `self.tabs` as immutable because it is also borrowed as mutable","code":{"code":"E0502","explanation":"A variable already borrowed with a certain mutability (either mutable or\nimmutable) was borrowed again with a different mutability.\n\nErroneous code example:\n\n```compile_fail,E0502\nfn bar(x: &mut i32) {}\nfn foo(a: &mut i32) {\n    let y = &a; // a is borrowed as immutable.\n    bar(a); // error: cannot borrow `*a` as mutable because `a` is also borrowed\n            //        as immutable\n    println!(\"{}\", y);\n}\n```\n\nTo fix this error, ensure that you don't have any other references to the\nvariable before trying to access it with a different mutability:\n\n```\nfn bar(x: &mut i32) {}\nfn foo(a: &mut i32) {\n    bar(a);\n    let y = &a; // ok!\n    println!(\"{}\", y);\n}\n```\n\nFor more information on Rust's ownership system, take a look at the\n[References & Borrowing][references-and-borrowing] section of the Book.\n\n[references-and-borrowing]: https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":4165,"byte_end":4174,"line_start":149,"line_end":149,"column_start":35,"column_end":44,"is_primary":true,"text":[{"text":"                self.active_tab = self.tabs.len() - 1;","highlight_start":35,"highlight_end":44}],"label":"immutable borrow occurs here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":3753,"byte_end":3757,"line_start":136,"line_end":136,"column_start":19,"column_end":23,"is_primary":false,"text":[{"text":"        let tab = self.active_tab();","highlight_start":19,"highlight_end":23}],"label":"mutable borrow occurs here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":11901,"byte_end":11925,"line_start":330,"line_end":330,"column_start":12,"column_end":36,"is_primary":false,"text":[{"text":"        if tab.cursor.position.line < tab.scroll_offset {","highlight_start":12,"highlight_end":36}],"label":"mutable borrow later used here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0502]\u001b[0m\u001b[1m: cannot borrow `self.tabs` as immutable because it is also borrowed as mutable\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:149:35\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m136\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         let tab = self.active_tab();\n    \u001b[1m\u001b[94m|\u001b[0m                   \u001b[1m\u001b[94m----\u001b[0m \u001b[1m\u001b[94mmutable borrow occurs here\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m149\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                 self.active_tab = self.tabs.len() - 1;\n    \u001b[1m\u001b[94m|\u001b[0m                                   \u001b[1m\u001b[91m^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mimmutable borrow occurs here\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m330\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         if tab.cursor.position.line < tab.scroll_offset {\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[94m------------------------\u001b[0m \u001b[1m\u001b[94mmutable borrow later used here\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot borrow `self.tabs` as immutable because it is also borrowed as mutable","code":{"code":"E0502","explanation":"A variable already borrowed with a certain mutability (either mutable or\nimmutable) was borrowed again with a different mutability.\n\nErroneous code example:\n\n```compile_fail,E0502\nfn bar(x: &mut i32) {}\nfn foo(a: &mut i32) {\n    let y = &a; // a is borrowed as immutable.\n    bar(a); // error: cannot borrow `*a` as mutable because `a` is also borrowed\n            //        as immutable\n    println!(\"{}\", y);\n}\n```\n\nTo fix this error, ensure that you don't have any other references to the\nvariable before trying to access it with a different mutability:\n\n```\nfn bar(x: &mut i32) {}\nfn foo(a: &mut i32) {\n    bar(a);\n    let y = &a; // ok!\n    println!(\"{}\", y);\n}\n```\n\nFor more information on Rust's ownership system, take a look at the\n[References & Borrowing][references-and-borrowing] section of the Book.\n\n[references-and-borrowing]: https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":4251,"byte_end":4260,"line_start":152,"line_end":152,"column_start":20,"column_end":29,"is_primary":true,"text":[{"text":"                if self.tabs.len() > 1 {","highlight_start":20,"highlight_end":29}],"label":"immutable borrow occurs here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":3753,"byte_end":3757,"line_start":136,"line_end":136,"column_start":19,"column_end":23,"is_primary":false,"text":[{"text":"        let tab = self.active_tab();","highlight_start":19,"highlight_end":23}],"label":"mutable borrow occurs here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":11901,"byte_end":11925,"line_start":330,"line_end":330,"column_start":12,"column_end":36,"is_primary":false,"text":[{"text":"        if tab.cursor.position.line < tab.scroll_offset {","highlight_start":12,"highlight_end":36}],"label":"mutable borrow later used here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0502]\u001b[0m\u001b[1m: cannot borrow `self.tabs` as immutable because it is also borrowed as mutable\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:152:20\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m136\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         let tab = self.active_tab();\n    \u001b[1m\u001b[94m|\u001b[0m                   \u001b[1m\u001b[94m----\u001b[0m \u001b[1m\u001b[94mmutable borrow occurs here\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m152\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                 if self.tabs.len() > 1 {\n    \u001b[1m\u001b[94m|\u001b[0m                    \u001b[1m\u001b[91m^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mimmutable borrow occurs here\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m330\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         if tab.cursor.position.line < tab.scroll_offset {\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[94m------------------------\u001b[0m \u001b[1m\u001b[94mmutable borrow later used here\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot borrow `self.tabs` as mutable more than once at a time","code":{"code":"E0499","explanation":"A variable was borrowed as mutable more than once.\n\nErroneous code example:\n\n```compile_fail,E0499\nlet mut i = 0;\nlet mut x = &mut i;\nlet mut a = &mut i;\nx;\n// error: cannot borrow `i` as mutable more than once at a time\n```\n\nPlease note that in Rust, you can either have many immutable references, or one\nmutable reference. For more details you may want to read the\n[References & Borrowing][references-and-borrowing] section of the Book.\n\n[references-and-borrowing]: https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html\n\nExample:\n\n```\nlet mut i = 0;\nlet mut x = &mut i; // ok!\n\n// or:\nlet mut i = 0;\nlet a = &i; // ok!\nlet b = &i; // still ok!\nlet c = &i; // still ok!\nb;\na;\n```\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":3753,"byte_end":3757,"line_start":136,"line_end":136,"column_start":19,"column_end":23,"is_primary":false,"text":[{"text":"        let tab = self.active_tab();","highlight_start":19,"highlight_end":23}],"label":"first mutable borrow occurs here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":4293,"byte_end":4302,"line_start":153,"line_end":153,"column_start":21,"column_end":30,"is_primary":true,"text":[{"text":"                    self.tabs.remove(self.active_tab);","highlight_start":21,"highlight_end":30}],"label":"second mutable borrow occurs here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":11901,"byte_end":11925,"line_start":330,"line_end":330,"column_start":12,"column_end":36,"is_primary":false,"text":[{"text":"        if tab.cursor.position.line < tab.scroll_offset {","highlight_start":12,"highlight_end":36}],"label":"first borrow later used here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0499]\u001b[0m\u001b[1m: cannot borrow `self.tabs` as mutable more than once at a time\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:153:21\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m136\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         let tab = self.active_tab();\n    \u001b[1m\u001b[94m|\u001b[0m                   \u001b[1m\u001b[94m----\u001b[0m \u001b[1m\u001b[94mfirst mutable borrow occurs here\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m153\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                     self.tabs.remove(self.active_tab);\n    \u001b[1m\u001b[94m|\u001b[0m                     \u001b[1m\u001b[91m^^^^^^^^^\u001b[0m \u001b[1m\u001b[91msecond mutable borrow occurs here\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m330\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         if tab.cursor.position.line < tab.scroll_offset {\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[94m------------------------\u001b[0m \u001b[1m\u001b[94mfirst borrow later used here\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot use `self.active_tab` because it was mutably borrowed","code":{"code":"E0503","explanation":"A value was used after it was mutably borrowed.\n\nErroneous code example:\n\n```compile_fail,E0503\nfn main() {\n    let mut value = 3;\n    // Create a mutable borrow of `value`.\n    let borrow = &mut value;\n    let _sum = value + 1; // error: cannot use `value` because\n                          //        it was mutably borrowed\n    println!(\"{}\", borrow);\n}\n```\n\nIn this example, `value` is mutably borrowed by `borrow` and cannot be\nused to calculate `sum`. This is not possible because this would violate\nRust's mutability rules.\n\nYou can fix this error by finishing using the borrow before the next use of\nthe value:\n\n```\nfn main() {\n    let mut value = 3;\n    let borrow = &mut value;\n    println!(\"{}\", borrow);\n    // The block has ended and with it the borrow.\n    // You can now use `value` again.\n    let _sum = value + 1;\n}\n```\n\nOr by cloning `value` before borrowing it:\n\n```\nfn main() {\n    let mut value = 3;\n    // We clone `value`, creating a copy.\n    let value_cloned = value.clone();\n    // The mutable borrow is a reference to `value` and\n    // not to `value_cloned`...\n    let borrow = &mut value;\n    // ... which means we can still use `value_cloned`,\n    let _sum = value_cloned + 1;\n    // even though the borrow only ends here.\n    println!(\"{}\", borrow);\n}\n```\n\nFor more information on Rust's ownership system, take a look at the\n[References & Borrowing][references-and-borrowing] section of the Book.\n\n[references-and-borrowing]: https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":3753,"byte_end":3757,"line_start":136,"line_end":136,"column_start":19,"column_end":23,"is_primary":false,"text":[{"text":"        let tab = self.active_tab();","highlight_start":19,"highlight_end":23}],"label":"`*self` is borrowed here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":4310,"byte_end":4325,"line_start":153,"line_end":153,"column_start":38,"column_end":53,"is_primary":true,"text":[{"text":"                    self.tabs.remove(self.active_tab);","highlight_start":38,"highlight_end":53}],"label":"use of borrowed `*self`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":11901,"byte_end":11925,"line_start":330,"line_end":330,"column_start":12,"column_end":36,"is_primary":false,"text":[{"text":"        if tab.cursor.position.line < tab.scroll_offset {","highlight_start":12,"highlight_end":36}],"label":"borrow later used here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0503]\u001b[0m\u001b[1m: cannot use `self.active_tab` because it was mutably borrowed\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:153:38\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m136\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         let tab = self.active_tab();\n    \u001b[1m\u001b[94m|\u001b[0m                   \u001b[1m\u001b[94m----\u001b[0m \u001b[1m\u001b[94m`*self` is borrowed here\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m153\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                     self.tabs.remove(self.active_tab);\n    \u001b[1m\u001b[94m|\u001b[0m                                      \u001b[1m\u001b[91m^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91muse of borrowed `*self`\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m330\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         if tab.cursor.position.line < tab.scroll_offset {\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[94m------------------------\u001b[0m \u001b[1m\u001b[94mborrow later used here\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot use `self.active_tab` because it was mutably borrowed","code":{"code":"E0503","explanation":"A value was used after it was mutably borrowed.\n\nErroneous code example:\n\n```compile_fail,E0503\nfn main() {\n    let mut value = 3;\n    // Create a mutable borrow of `value`.\n    let borrow = &mut value;\n    let _sum = value + 1; // error: cannot use `value` because\n                          //        it was mutably borrowed\n    println!(\"{}\", borrow);\n}\n```\n\nIn this example, `value` is mutably borrowed by `borrow` and cannot be\nused to calculate `sum`. This is not possible because this would violate\nRust's mutability rules.\n\nYou can fix this error by finishing using the borrow before the next use of\nthe value:\n\n```\nfn main() {\n    let mut value = 3;\n    let borrow = &mut value;\n    println!(\"{}\", borrow);\n    // The block has ended and with it the borrow.\n    // You can now use `value` again.\n    let _sum = value + 1;\n}\n```\n\nOr by cloning `value` before borrowing it:\n\n```\nfn main() {\n    let mut value = 3;\n    // We clone `value`, creating a copy.\n    let value_cloned = value.clone();\n    // The mutable borrow is a reference to `value` and\n    // not to `value_cloned`...\n    let borrow = &mut value;\n    // ... which means we can still use `value_cloned`,\n    let _sum = value_cloned + 1;\n    // even though the borrow only ends here.\n    println!(\"{}\", borrow);\n}\n```\n\nFor more information on Rust's ownership system, take a look at the\n[References & Borrowing][references-and-borrowing] section of the Book.\n\n[references-and-borrowing]: https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":3753,"byte_end":3757,"line_start":136,"line_end":136,"column_start":19,"column_end":23,"is_primary":false,"text":[{"text":"        let tab = self.active_tab();","highlight_start":19,"highlight_end":23}],"label":"`*self` is borrowed here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":4351,"byte_end":4366,"line_start":154,"line_end":154,"column_start":24,"column_end":39,"is_primary":true,"text":[{"text":"                    if self.active_tab >= self.tabs.len() {","highlight_start":24,"highlight_end":39}],"label":"use of borrowed `*self`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":11901,"byte_end":11925,"line_start":330,"line_end":330,"column_start":12,"column_end":36,"is_primary":false,"text":[{"text":"        if tab.cursor.position.line < tab.scroll_offset {","highlight_start":12,"highlight_end":36}],"label":"borrow later used here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0503]\u001b[0m\u001b[1m: cannot use `self.active_tab` because it was mutably borrowed\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:154:24\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m136\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         let tab = self.active_tab();\n    \u001b[1m\u001b[94m|\u001b[0m                   \u001b[1m\u001b[94m----\u001b[0m \u001b[1m\u001b[94m`*self` is borrowed here\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m154\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                     if self.active_tab >= self.tabs.len() {\n    \u001b[1m\u001b[94m|\u001b[0m                        \u001b[1m\u001b[91m^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91muse of borrowed `*self`\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m330\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         if tab.cursor.position.line < tab.scroll_offset {\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[94m------------------------\u001b[0m \u001b[1m\u001b[94mborrow later used here\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot borrow `self.tabs` as immutable because it is also borrowed as mutable","code":{"code":"E0502","explanation":"A variable already borrowed with a certain mutability (either mutable or\nimmutable) was borrowed again with a different mutability.\n\nErroneous code example:\n\n```compile_fail,E0502\nfn bar(x: &mut i32) {}\nfn foo(a: &mut i32) {\n    let y = &a; // a is borrowed as immutable.\n    bar(a); // error: cannot borrow `*a` as mutable because `a` is also borrowed\n            //        as immutable\n    println!(\"{}\", y);\n}\n```\n\nTo fix this error, ensure that you don't have any other references to the\nvariable before trying to access it with a different mutability:\n\n```\nfn bar(x: &mut i32) {}\nfn foo(a: &mut i32) {\n    bar(a);\n    let y = &a; // ok!\n    println!(\"{}\", y);\n}\n```\n\nFor more information on Rust's ownership system, take a look at the\n[References & Borrowing][references-and-borrowing] section of the Book.\n\n[references-and-borrowing]: https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":4370,"byte_end":4379,"line_start":154,"line_end":154,"column_start":43,"column_end":52,"is_primary":true,"text":[{"text":"                    if self.active_tab >= self.tabs.len() {","highlight_start":43,"highlight_end":52}],"label":"immutable borrow occurs here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":3753,"byte_end":3757,"line_start":136,"line_end":136,"column_start":19,"column_end":23,"is_primary":false,"text":[{"text":"        let tab = self.active_tab();","highlight_start":19,"highlight_end":23}],"label":"mutable borrow occurs here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":11901,"byte_end":11925,"line_start":330,"line_end":330,"column_start":12,"column_end":36,"is_primary":false,"text":[{"text":"        if tab.cursor.position.line < tab.scroll_offset {","highlight_start":12,"highlight_end":36}],"label":"mutable borrow later used here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0502]\u001b[0m\u001b[1m: cannot borrow `self.tabs` as immutable because it is also borrowed as mutable\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:154:43\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m136\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         let tab = self.active_tab();\n    \u001b[1m\u001b[94m|\u001b[0m                   \u001b[1m\u001b[94m----\u001b[0m \u001b[1m\u001b[94mmutable borrow occurs here\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m154\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                     if self.active_tab >= self.tabs.len() {\n    \u001b[1m\u001b[94m|\u001b[0m                                           \u001b[1m\u001b[91m^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mimmutable borrow occurs here\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m330\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         if tab.cursor.position.line < tab.scroll_offset {\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[94m------------------------\u001b[0m \u001b[1m\u001b[94mmutable borrow later used here\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot assign to `self.active_tab` because it is borrowed","code":{"code":"E0506","explanation":"An attempt was made to assign to a borrowed value.\n\nErroneous code example:\n\n```compile_fail,E0506\nstruct FancyNum {\n    num: u8,\n}\n\nlet mut fancy_num = FancyNum { num: 5 };\nlet fancy_ref = &fancy_num;\nfancy_num = FancyNum { num: 6 };\n// error: cannot assign to `fancy_num` because it is borrowed\n\nprintln!(\"Num: {}, Ref: {}\", fancy_num.num, fancy_ref.num);\n```\n\nBecause `fancy_ref` still holds a reference to `fancy_num`, `fancy_num` can't\nbe assigned to a new value as it would invalidate the reference.\n\nAlternatively, we can move out of `fancy_num` into a second `fancy_num`:\n\n```\nstruct FancyNum {\n    num: u8,\n}\n\nlet mut fancy_num = FancyNum { num: 5 };\nlet moved_num = fancy_num;\nfancy_num = FancyNum { num: 6 };\n\nprintln!(\"Num: {}, Moved num: {}\", fancy_num.num, moved_num.num);\n```\n\nIf the value has to be borrowed, try limiting the lifetime of the borrow using\na scoped block:\n\n```\nstruct FancyNum {\n    num: u8,\n}\n\nlet mut fancy_num = FancyNum { num: 5 };\n\n{\n    let fancy_ref = &fancy_num;\n    println!(\"Ref: {}\", fancy_ref.num);\n}\n\n// Works because `fancy_ref` is no longer in scope\nfancy_num = FancyNum { num: 6 };\nprintln!(\"Num: {}\", fancy_num.num);\n```\n\nOr by moving the reference into a function:\n\n```\nstruct FancyNum {\n    num: u8,\n}\n\nfn print_fancy_ref(fancy_ref: &FancyNum){\n    println!(\"Ref: {}\", fancy_ref.num);\n}\n\nlet mut fancy_num = FancyNum { num: 5 };\n\nprint_fancy_ref(&fancy_num);\n\n// Works because function borrow has ended\nfancy_num = FancyNum { num: 6 };\nprintln!(\"Num: {}\", fancy_num.num);\n```\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":3753,"byte_end":3757,"line_start":136,"line_end":136,"column_start":19,"column_end":23,"is_primary":false,"text":[{"text":"        let tab = self.active_tab();","highlight_start":19,"highlight_end":23}],"label":"`self.active_tab` is borrowed here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":4412,"byte_end":4449,"line_start":155,"line_end":155,"column_start":25,"column_end":62,"is_primary":true,"text":[{"text":"                        self.active_tab = self.tabs.len() - 1;","highlight_start":25,"highlight_end":62}],"label":"`self.active_tab` is assigned to here but it was already borrowed","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":11901,"byte_end":11925,"line_start":330,"line_end":330,"column_start":12,"column_end":36,"is_primary":false,"text":[{"text":"        if tab.cursor.position.line < tab.scroll_offset {","highlight_start":12,"highlight_end":36}],"label":"borrow later used here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0506]\u001b[0m\u001b[1m: cannot assign to `self.active_tab` because it is borrowed\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:155:25\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m136\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         let tab = self.active_tab();\n    \u001b[1m\u001b[94m|\u001b[0m                   \u001b[1m\u001b[94m----\u001b[0m \u001b[1m\u001b[94m`self.active_tab` is borrowed here\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m155\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                         self.active_tab = self.tabs.len() - 1;\n    \u001b[1m\u001b[94m|\u001b[0m                         \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91m`self.active_tab` is assigned to here but it was already borrowed\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m330\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         if tab.cursor.position.line < tab.scroll_offset {\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[94m------------------------\u001b[0m \u001b[1m\u001b[94mborrow later used here\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot borrow `self.tabs` as immutable because it is also borrowed as mutable","code":{"code":"E0502","explanation":"A variable already borrowed with a certain mutability (either mutable or\nimmutable) was borrowed again with a different mutability.\n\nErroneous code example:\n\n```compile_fail,E0502\nfn bar(x: &mut i32) {}\nfn foo(a: &mut i32) {\n    let y = &a; // a is borrowed as immutable.\n    bar(a); // error: cannot borrow `*a` as mutable because `a` is also borrowed\n            //        as immutable\n    println!(\"{}\", y);\n}\n```\n\nTo fix this error, ensure that you don't have any other references to the\nvariable before trying to access it with a different mutability:\n\n```\nfn bar(x: &mut i32) {}\nfn foo(a: &mut i32) {\n    bar(a);\n    let y = &a; // ok!\n    println!(\"{}\", y);\n}\n```\n\nFor more information on Rust's ownership system, take a look at the\n[References & Borrowing][references-and-borrowing] section of the Book.\n\n[references-and-borrowing]: https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":4430,"byte_end":4439,"line_start":155,"line_end":155,"column_start":43,"column_end":52,"is_primary":true,"text":[{"text":"                        self.active_tab = self.tabs.len() - 1;","highlight_start":43,"highlight_end":52}],"label":"immutable borrow occurs here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":3753,"byte_end":3757,"line_start":136,"line_end":136,"column_start":19,"column_end":23,"is_primary":false,"text":[{"text":"        let tab = self.active_tab();","highlight_start":19,"highlight_end":23}],"label":"mutable borrow occurs here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":11901,"byte_end":11925,"line_start":330,"line_end":330,"column_start":12,"column_end":36,"is_primary":false,"text":[{"text":"        if tab.cursor.position.line < tab.scroll_offset {","highlight_start":12,"highlight_end":36}],"label":"mutable borrow later used here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0502]\u001b[0m\u001b[1m: cannot borrow `self.tabs` as immutable because it is also borrowed as mutable\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:155:43\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m136\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         let tab = self.active_tab();\n    \u001b[1m\u001b[94m|\u001b[0m                   \u001b[1m\u001b[94m----\u001b[0m \u001b[1m\u001b[94mmutable borrow occurs here\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m155\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                         self.active_tab = self.tabs.len() - 1;\n    \u001b[1m\u001b[94m|\u001b[0m                                           \u001b[1m\u001b[91m^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mimmutable borrow occurs here\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m330\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         if tab.cursor.position.line < tab.scroll_offset {\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[94m------------------------\u001b[0m \u001b[1m\u001b[94mmutable borrow later used here\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot use `self.settings.use_spaces` because it was mutably borrowed","code":{"code":"E0503","explanation":"A value was used after it was mutably borrowed.\n\nErroneous code example:\n\n```compile_fail,E0503\nfn main() {\n    let mut value = 3;\n    // Create a mutable borrow of `value`.\n    let borrow = &mut value;\n    let _sum = value + 1; // error: cannot use `value` because\n                          //        it was mutably borrowed\n    println!(\"{}\", borrow);\n}\n```\n\nIn this example, `value` is mutably borrowed by `borrow` and cannot be\nused to calculate `sum`. This is not possible because this would violate\nRust's mutability rules.\n\nYou can fix this error by finishing using the borrow before the next use of\nthe value:\n\n```\nfn main() {\n    let mut value = 3;\n    let borrow = &mut value;\n    println!(\"{}\", borrow);\n    // The block has ended and with it the borrow.\n    // You can now use `value` again.\n    let _sum = value + 1;\n}\n```\n\nOr by cloning `value` before borrowing it:\n\n```\nfn main() {\n    let mut value = 3;\n    // We clone `value`, creating a copy.\n    let value_cloned = value.clone();\n    // The mutable borrow is a reference to `value` and\n    // not to `value_cloned`...\n    let borrow = &mut value;\n    // ... which means we can still use `value_cloned`,\n    let _sum = value_cloned + 1;\n    // even though the borrow only ends here.\n    println!(\"{}\", borrow);\n}\n```\n\nFor more information on Rust's ownership system, take a look at the\n[References & Borrowing][references-and-borrowing] section of the Book.\n\n[references-and-borrowing]: https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":3753,"byte_end":3757,"line_start":136,"line_end":136,"column_start":19,"column_end":23,"is_primary":false,"text":[{"text":"        let tab = self.active_tab();","highlight_start":19,"highlight_end":23}],"label":"`*self` is borrowed here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":8677,"byte_end":8701,"line_start":256,"line_end":256,"column_start":33,"column_end":57,"is_primary":true,"text":[{"text":"                let spaces = if self.settings.use_spaces {","highlight_start":33,"highlight_end":57}],"label":"use of borrowed `*self`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":8866,"byte_end":8876,"line_start":261,"line_end":261,"column_start":27,"column_end":37,"is_primary":false,"text":[{"text":"                let idx = tab.cursor.get_char_idx(&tab.buffer);","highlight_start":27,"highlight_end":37}],"label":"borrow later used here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0503]\u001b[0m\u001b[1m: cannot use `self.settings.use_spaces` because it was mutably borrowed\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:256:33\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m136\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         let tab = self.active_tab();\n    \u001b[1m\u001b[94m|\u001b[0m                   \u001b[1m\u001b[94m----\u001b[0m \u001b[1m\u001b[94m`*self` is borrowed here\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m256\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                 let spaces = if self.settings.use_spaces {\n    \u001b[1m\u001b[94m|\u001b[0m                                 \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91muse of borrowed `*self`\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m261\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                 let idx = tab.cursor.get_char_idx(&tab.buffer);\n    \u001b[1m\u001b[94m|\u001b[0m                           \u001b[1m\u001b[94m----------\u001b[0m \u001b[1m\u001b[94mborrow later used here\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot use `self.settings.tab_size` because it was mutably borrowed","code":{"code":"E0503","explanation":"A value was used after it was mutably borrowed.\n\nErroneous code example:\n\n```compile_fail,E0503\nfn main() {\n    let mut value = 3;\n    // Create a mutable borrow of `value`.\n    let borrow = &mut value;\n    let _sum = value + 1; // error: cannot use `value` because\n                          //        it was mutably borrowed\n    println!(\"{}\", borrow);\n}\n```\n\nIn this example, `value` is mutably borrowed by `borrow` and cannot be\nused to calculate `sum`. This is not possible because this would violate\nRust's mutability rules.\n\nYou can fix this error by finishing using the borrow before the next use of\nthe value:\n\n```\nfn main() {\n    let mut value = 3;\n    let borrow = &mut value;\n    println!(\"{}\", borrow);\n    // The block has ended and with it the borrow.\n    // You can now use `value` again.\n    let _sum = value + 1;\n}\n```\n\nOr by cloning `value` before borrowing it:\n\n```\nfn main() {\n    let mut value = 3;\n    // We clone `value`, creating a copy.\n    let value_cloned = value.clone();\n    // The mutable borrow is a reference to `value` and\n    // not to `value_cloned`...\n    let borrow = &mut value;\n    // ... which means we can still use `value_cloned`,\n    let _sum = value_cloned + 1;\n    // even though the borrow only ends here.\n    println!(\"{}\", borrow);\n}\n```\n\nFor more information on Rust's ownership system, take a look at the\n[References & Borrowing][references-and-borrowing] section of the Book.\n\n[references-and-borrowing]: https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":3753,"byte_end":3757,"line_start":136,"line_end":136,"column_start":19,"column_end":23,"is_primary":false,"text":[{"text":"        let tab = self.active_tab();","highlight_start":19,"highlight_end":23}],"label":"`*self` is borrowed here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":8735,"byte_end":8757,"line_start":257,"line_end":257,"column_start":32,"column_end":54,"is_primary":true,"text":[{"text":"                    \" \".repeat(self.settings.tab_size)","highlight_start":32,"highlight_end":54}],"label":"use of borrowed `*self`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":8866,"byte_end":8876,"line_start":261,"line_end":261,"column_start":27,"column_end":37,"is_primary":false,"text":[{"text":"                let idx = tab.cursor.get_char_idx(&tab.buffer);","highlight_start":27,"highlight_end":37}],"label":"borrow later used here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0503]\u001b[0m\u001b[1m: cannot use `self.settings.tab_size` because it was mutably borrowed\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:257:32\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m136\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         let tab = self.active_tab();\n    \u001b[1m\u001b[94m|\u001b[0m                   \u001b[1m\u001b[94m----\u001b[0m \u001b[1m\u001b[94m`*self` is borrowed here\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m257\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                     \" \".repeat(self.settings.tab_size)\n    \u001b[1m\u001b[94m|\u001b[0m                                \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91muse of borrowed `*self`\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m261\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                 let idx = tab.cursor.get_char_idx(&tab.buffer);\n    \u001b[1m\u001b[94m|\u001b[0m                           \u001b[1m\u001b[94m----------\u001b[0m \u001b[1m\u001b[94mborrow later used here\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot assign to `self.show_line_numbers` because it is borrowed","code":{"code":"E0506","explanation":"An attempt was made to assign to a borrowed value.\n\nErroneous code example:\n\n```compile_fail,E0506\nstruct FancyNum {\n    num: u8,\n}\n\nlet mut fancy_num = FancyNum { num: 5 };\nlet fancy_ref = &fancy_num;\nfancy_num = FancyNum { num: 6 };\n// error: cannot assign to `fancy_num` because it is borrowed\n\nprintln!(\"Num: {}, Ref: {}\", fancy_num.num, fancy_ref.num);\n```\n\nBecause `fancy_ref` still holds a reference to `fancy_num`, `fancy_num` can't\nbe assigned to a new value as it would invalidate the reference.\n\nAlternatively, we can move out of `fancy_num` into a second `fancy_num`:\n\n```\nstruct FancyNum {\n    num: u8,\n}\n\nlet mut fancy_num = FancyNum { num: 5 };\nlet moved_num = fancy_num;\nfancy_num = FancyNum { num: 6 };\n\nprintln!(\"Num: {}, Moved num: {}\", fancy_num.num, moved_num.num);\n```\n\nIf the value has to be borrowed, try limiting the lifetime of the borrow using\na scoped block:\n\n```\nstruct FancyNum {\n    num: u8,\n}\n\nlet mut fancy_num = FancyNum { num: 5 };\n\n{\n    let fancy_ref = &fancy_num;\n    println!(\"Ref: {}\", fancy_ref.num);\n}\n\n// Works because `fancy_ref` is no longer in scope\nfancy_num = FancyNum { num: 6 };\nprintln!(\"Num: {}\", fancy_num.num);\n```\n\nOr by moving the reference into a function:\n\n```\nstruct FancyNum {\n    num: u8,\n}\n\nfn print_fancy_ref(fancy_ref: &FancyNum){\n    println!(\"Ref: {}\", fancy_ref.num);\n}\n\nlet mut fancy_num = FancyNum { num: 5 };\n\nprint_fancy_ref(&fancy_num);\n\n// Works because function borrow has ended\nfancy_num = FancyNum { num: 6 };\nprintln!(\"Num: {}\", fancy_num.num);\n```\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":3753,"byte_end":3757,"line_start":136,"line_end":136,"column_start":19,"column_end":23,"is_primary":false,"text":[{"text":"        let tab = self.active_tab();","highlight_start":19,"highlight_end":23}],"label":"`self.show_line_numbers` is borrowed here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":9912,"byte_end":9960,"line_start":283,"line_end":283,"column_start":17,"column_end":65,"is_primary":true,"text":[{"text":"                self.show_line_numbers = !self.show_line_numbers;","highlight_start":17,"highlight_end":65}],"label":"`self.show_line_numbers` is assigned to here but it was already borrowed","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":11901,"byte_end":11925,"line_start":330,"line_end":330,"column_start":12,"column_end":36,"is_primary":false,"text":[{"text":"        if tab.cursor.position.line < tab.scroll_offset {","highlight_start":12,"highlight_end":36}],"label":"borrow later used here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0506]\u001b[0m\u001b[1m: cannot assign to `self.show_line_numbers` because it is borrowed\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:283:17\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m136\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         let tab = self.active_tab();\n    \u001b[1m\u001b[94m|\u001b[0m                   \u001b[1m\u001b[94m----\u001b[0m \u001b[1m\u001b[94m`self.show_line_numbers` is borrowed here\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m283\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                 self.show_line_numbers = !self.show_line_numbers;\n    \u001b[1m\u001b[94m|\u001b[0m                 \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91m`self.show_line_numbers` is assigned to here but it was already borrowed\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m330\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         if tab.cursor.position.line < tab.scroll_offset {\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[94m------------------------\u001b[0m \u001b[1m\u001b[94mborrow later used here\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot use `self.show_line_numbers` because it was mutably borrowed","code":{"code":"E0503","explanation":"A value was used after it was mutably borrowed.\n\nErroneous code example:\n\n```compile_fail,E0503\nfn main() {\n    let mut value = 3;\n    // Create a mutable borrow of `value`.\n    let borrow = &mut value;\n    let _sum = value + 1; // error: cannot use `value` because\n                          //        it was mutably borrowed\n    println!(\"{}\", borrow);\n}\n```\n\nIn this example, `value` is mutably borrowed by `borrow` and cannot be\nused to calculate `sum`. This is not possible because this would violate\nRust's mutability rules.\n\nYou can fix this error by finishing using the borrow before the next use of\nthe value:\n\n```\nfn main() {\n    let mut value = 3;\n    let borrow = &mut value;\n    println!(\"{}\", borrow);\n    // The block has ended and with it the borrow.\n    // You can now use `value` again.\n    let _sum = value + 1;\n}\n```\n\nOr by cloning `value` before borrowing it:\n\n```\nfn main() {\n    let mut value = 3;\n    // We clone `value`, creating a copy.\n    let value_cloned = value.clone();\n    // The mutable borrow is a reference to `value` and\n    // not to `value_cloned`...\n    let borrow = &mut value;\n    // ... which means we can still use `value_cloned`,\n    let _sum = value_cloned + 1;\n    // even though the borrow only ends here.\n    println!(\"{}\", borrow);\n}\n```\n\nFor more information on Rust's ownership system, take a look at the\n[References & Borrowing][references-and-borrowing] section of the Book.\n\n[references-and-borrowing]: https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":3753,"byte_end":3757,"line_start":136,"line_end":136,"column_start":19,"column_end":23,"is_primary":false,"text":[{"text":"        let tab = self.active_tab();","highlight_start":19,"highlight_end":23}],"label":"`*self` is borrowed here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":9938,"byte_end":9960,"line_start":283,"line_end":283,"column_start":43,"column_end":65,"is_primary":true,"text":[{"text":"                self.show_line_numbers = !self.show_line_numbers;","highlight_start":43,"highlight_end":65}],"label":"use of borrowed `*self`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":11901,"byte_end":11925,"line_start":330,"line_end":330,"column_start":12,"column_end":36,"is_primary":false,"text":[{"text":"        if tab.cursor.position.line < tab.scroll_offset {","highlight_start":12,"highlight_end":36}],"label":"borrow later used here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0503]\u001b[0m\u001b[1m: cannot use `self.show_line_numbers` because it was mutably borrowed\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:283:43\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m136\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         let tab = self.active_tab();\n    \u001b[1m\u001b[94m|\u001b[0m                   \u001b[1m\u001b[94m----\u001b[0m \u001b[1m\u001b[94m`*self` is borrowed here\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m283\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                 self.show_line_numbers = !self.show_line_numbers;\n    \u001b[1m\u001b[94m|\u001b[0m                                           \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91muse of borrowed `*self`\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m330\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         if tab.cursor.position.line < tab.scroll_offset {\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[94m------------------------\u001b[0m \u001b[1m\u001b[94mborrow later used here\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot assign to `self.layout.show_help` because it is borrowed","code":{"code":"E0506","explanation":"An attempt was made to assign to a borrowed value.\n\nErroneous code example:\n\n```compile_fail,E0506\nstruct FancyNum {\n    num: u8,\n}\n\nlet mut fancy_num = FancyNum { num: 5 };\nlet fancy_ref = &fancy_num;\nfancy_num = FancyNum { num: 6 };\n// error: cannot assign to `fancy_num` because it is borrowed\n\nprintln!(\"Num: {}, Ref: {}\", fancy_num.num, fancy_ref.num);\n```\n\nBecause `fancy_ref` still holds a reference to `fancy_num`, `fancy_num` can't\nbe assigned to a new value as it would invalidate the reference.\n\nAlternatively, we can move out of `fancy_num` into a second `fancy_num`:\n\n```\nstruct FancyNum {\n    num: u8,\n}\n\nlet mut fancy_num = FancyNum { num: 5 };\nlet moved_num = fancy_num;\nfancy_num = FancyNum { num: 6 };\n\nprintln!(\"Num: {}, Moved num: {}\", fancy_num.num, moved_num.num);\n```\n\nIf the value has to be borrowed, try limiting the lifetime of the borrow using\na scoped block:\n\n```\nstruct FancyNum {\n    num: u8,\n}\n\nlet mut fancy_num = FancyNum { num: 5 };\n\n{\n    let fancy_ref = &fancy_num;\n    println!(\"Ref: {}\", fancy_ref.num);\n}\n\n// Works because `fancy_ref` is no longer in scope\nfancy_num = FancyNum { num: 6 };\nprintln!(\"Num: {}\", fancy_num.num);\n```\n\nOr by moving the reference into a function:\n\n```\nstruct FancyNum {\n    num: u8,\n}\n\nfn print_fancy_ref(fancy_ref: &FancyNum){\n    println!(\"Ref: {}\", fancy_ref.num);\n}\n\nlet mut fancy_num = FancyNum { num: 5 };\n\nprint_fancy_ref(&fancy_num);\n\n// Works because function borrow has ended\nfancy_num = FancyNum { num: 6 };\nprintln!(\"Num: {}\", fancy_num.num);\n```\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":3753,"byte_end":3757,"line_start":136,"line_end":136,"column_start":19,"column_end":23,"is_primary":false,"text":[{"text":"        let tab = self.active_tab();","highlight_start":19,"highlight_end":23}],"label":"`self.layout.show_help` is borrowed here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":10029,"byte_end":10075,"line_start":286,"line_end":286,"column_start":17,"column_end":63,"is_primary":true,"text":[{"text":"                self.layout.show_help = !self.layout.show_help;","highlight_start":17,"highlight_end":63}],"label":"`self.layout.show_help` is assigned to here but it was already borrowed","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":11901,"byte_end":11925,"line_start":330,"line_end":330,"column_start":12,"column_end":36,"is_primary":false,"text":[{"text":"        if tab.cursor.position.line < tab.scroll_offset {","highlight_start":12,"highlight_end":36}],"label":"borrow later used here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0506]\u001b[0m\u001b[1m: cannot assign to `self.layout.show_help` because it is borrowed\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:286:17\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m136\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         let tab = self.active_tab();\n    \u001b[1m\u001b[94m|\u001b[0m                   \u001b[1m\u001b[94m----\u001b[0m \u001b[1m\u001b[94m`self.layout.show_help` is borrowed here\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m286\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                 self.layout.show_help = !self.layout.show_help;\n    \u001b[1m\u001b[94m|\u001b[0m                 \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91m`self.layout.show_help` is assigned to here but it was already borrowed\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m330\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         if tab.cursor.position.line < tab.scroll_offset {\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[94m------------------------\u001b[0m \u001b[1m\u001b[94mborrow later used here\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot use `self.layout.show_help` because it was mutably borrowed","code":{"code":"E0503","explanation":"A value was used after it was mutably borrowed.\n\nErroneous code example:\n\n```compile_fail,E0503\nfn main() {\n    let mut value = 3;\n    // Create a mutable borrow of `value`.\n    let borrow = &mut value;\n    let _sum = value + 1; // error: cannot use `value` because\n                          //        it was mutably borrowed\n    println!(\"{}\", borrow);\n}\n```\n\nIn this example, `value` is mutably borrowed by `borrow` and cannot be\nused to calculate `sum`. This is not possible because this would violate\nRust's mutability rules.\n\nYou can fix this error by finishing using the borrow before the next use of\nthe value:\n\n```\nfn main() {\n    let mut value = 3;\n    let borrow = &mut value;\n    println!(\"{}\", borrow);\n    // The block has ended and with it the borrow.\n    // You can now use `value` again.\n    let _sum = value + 1;\n}\n```\n\nOr by cloning `value` before borrowing it:\n\n```\nfn main() {\n    let mut value = 3;\n    // We clone `value`, creating a copy.\n    let value_cloned = value.clone();\n    // The mutable borrow is a reference to `value` and\n    // not to `value_cloned`...\n    let borrow = &mut value;\n    // ... which means we can still use `value_cloned`,\n    let _sum = value_cloned + 1;\n    // even though the borrow only ends here.\n    println!(\"{}\", borrow);\n}\n```\n\nFor more information on Rust's ownership system, take a look at the\n[References & Borrowing][references-and-borrowing] section of the Book.\n\n[references-and-borrowing]: https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":3753,"byte_end":3757,"line_start":136,"line_end":136,"column_start":19,"column_end":23,"is_primary":false,"text":[{"text":"        let tab = self.active_tab();","highlight_start":19,"highlight_end":23}],"label":"`*self` is borrowed here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":10054,"byte_end":10075,"line_start":286,"line_end":286,"column_start":42,"column_end":63,"is_primary":true,"text":[{"text":"                self.layout.show_help = !self.layout.show_help;","highlight_start":42,"highlight_end":63}],"label":"use of borrowed `*self`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":11901,"byte_end":11925,"line_start":330,"line_end":330,"column_start":12,"column_end":36,"is_primary":false,"text":[{"text":"        if tab.cursor.position.line < tab.scroll_offset {","highlight_start":12,"highlight_end":36}],"label":"borrow later used here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0503]\u001b[0m\u001b[1m: cannot use `self.layout.show_help` because it was mutably borrowed\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:286:42\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m136\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         let tab = self.active_tab();\n    \u001b[1m\u001b[94m|\u001b[0m                   \u001b[1m\u001b[94m----\u001b[0m \u001b[1m\u001b[94m`*self` is borrowed here\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m286\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                 self.layout.show_help = !self.layout.show_help;\n    \u001b[1m\u001b[94m|\u001b[0m                                          \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91muse of borrowed `*self`\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m330\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         if tab.cursor.position.line < tab.scroll_offset {\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[94m------------------------\u001b[0m \u001b[1m\u001b[94mborrow later used here\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot use `self.active_tab` because it was mutably borrowed","code":{"code":"E0503","explanation":"A value was used after it was mutably borrowed.\n\nErroneous code example:\n\n```compile_fail,E0503\nfn main() {\n    let mut value = 3;\n    // Create a mutable borrow of `value`.\n    let borrow = &mut value;\n    let _sum = value + 1; // error: cannot use `value` because\n                          //        it was mutably borrowed\n    println!(\"{}\", borrow);\n}\n```\n\nIn this example, `value` is mutably borrowed by `borrow` and cannot be\nused to calculate `sum`. This is not possible because this would violate\nRust's mutability rules.\n\nYou can fix this error by finishing using the borrow before the next use of\nthe value:\n\n```\nfn main() {\n    let mut value = 3;\n    let borrow = &mut value;\n    println!(\"{}\", borrow);\n    // The block has ended and with it the borrow.\n    // You can now use `value` again.\n    let _sum = value + 1;\n}\n```\n\nOr by cloning `value` before borrowing it:\n\n```\nfn main() {\n    let mut value = 3;\n    // We clone `value`, creating a copy.\n    let value_cloned = value.clone();\n    // The mutable borrow is a reference to `value` and\n    // not to `value_cloned`...\n    let borrow = &mut value;\n    // ... which means we can still use `value_cloned`,\n    let _sum = value_cloned + 1;\n    // even though the borrow only ends here.\n    println!(\"{}\", borrow);\n}\n```\n\nFor more information on Rust's ownership system, take a look at the\n[References & Borrowing][references-and-borrowing] section of the Book.\n\n[references-and-borrowing]: https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":3753,"byte_end":3757,"line_start":136,"line_end":136,"column_start":19,"column_end":23,"is_primary":false,"text":[{"text":"        let tab = self.active_tab();","highlight_start":19,"highlight_end":23}],"label":"`*self` is borrowed here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":10207,"byte_end":10222,"line_start":290,"line_end":290,"column_start":20,"column_end":35,"is_primary":true,"text":[{"text":"                if self.active_tab < self.tabs.len() - 1 {","highlight_start":20,"highlight_end":35}],"label":"use of borrowed `*self`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":11901,"byte_end":11925,"line_start":330,"line_end":330,"column_start":12,"column_end":36,"is_primary":false,"text":[{"text":"        if tab.cursor.position.line < tab.scroll_offset {","highlight_start":12,"highlight_end":36}],"label":"borrow later used here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0503]\u001b[0m\u001b[1m: cannot use `self.active_tab` because it was mutably borrowed\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:290:20\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m136\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         let tab = self.active_tab();\n    \u001b[1m\u001b[94m|\u001b[0m                   \u001b[1m\u001b[94m----\u001b[0m \u001b[1m\u001b[94m`*self` is borrowed here\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m290\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                 if self.active_tab < self.tabs.len() - 1 {\n    \u001b[1m\u001b[94m|\u001b[0m                    \u001b[1m\u001b[91m^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91muse of borrowed `*self`\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m330\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         if tab.cursor.position.line < tab.scroll_offset {\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[94m------------------------\u001b[0m \u001b[1m\u001b[94mborrow later used here\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot borrow `self.tabs` as immutable because it is also borrowed as mutable","code":{"code":"E0502","explanation":"A variable already borrowed with a certain mutability (either mutable or\nimmutable) was borrowed again with a different mutability.\n\nErroneous code example:\n\n```compile_fail,E0502\nfn bar(x: &mut i32) {}\nfn foo(a: &mut i32) {\n    let y = &a; // a is borrowed as immutable.\n    bar(a); // error: cannot borrow `*a` as mutable because `a` is also borrowed\n            //        as immutable\n    println!(\"{}\", y);\n}\n```\n\nTo fix this error, ensure that you don't have any other references to the\nvariable before trying to access it with a different mutability:\n\n```\nfn bar(x: &mut i32) {}\nfn foo(a: &mut i32) {\n    bar(a);\n    let y = &a; // ok!\n    println!(\"{}\", y);\n}\n```\n\nFor more information on Rust's ownership system, take a look at the\n[References & Borrowing][references-and-borrowing] section of the Book.\n\n[references-and-borrowing]: https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":10225,"byte_end":10234,"line_start":290,"line_end":290,"column_start":38,"column_end":47,"is_primary":true,"text":[{"text":"                if self.active_tab < self.tabs.len() - 1 {","highlight_start":38,"highlight_end":47}],"label":"immutable borrow occurs here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":3753,"byte_end":3757,"line_start":136,"line_end":136,"column_start":19,"column_end":23,"is_primary":false,"text":[{"text":"        let tab = self.active_tab();","highlight_start":19,"highlight_end":23}],"label":"mutable borrow occurs here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":11901,"byte_end":11925,"line_start":330,"line_end":330,"column_start":12,"column_end":36,"is_primary":false,"text":[{"text":"        if tab.cursor.position.line < tab.scroll_offset {","highlight_start":12,"highlight_end":36}],"label":"mutable borrow later used here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0502]\u001b[0m\u001b[1m: cannot borrow `self.tabs` as immutable because it is also borrowed as mutable\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:290:38\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m136\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         let tab = self.active_tab();\n    \u001b[1m\u001b[94m|\u001b[0m                   \u001b[1m\u001b[94m----\u001b[0m \u001b[1m\u001b[94mmutable borrow occurs here\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m290\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                 if self.active_tab < self.tabs.len() - 1 {\n    \u001b[1m\u001b[94m|\u001b[0m                                      \u001b[1m\u001b[91m^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mimmutable borrow occurs here\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m330\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         if tab.cursor.position.line < tab.scroll_offset {\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[94m------------------------\u001b[0m \u001b[1m\u001b[94mmutable borrow later used here\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot use `self.active_tab` because it was mutably borrowed","code":{"code":"E0503","explanation":"A value was used after it was mutably borrowed.\n\nErroneous code example:\n\n```compile_fail,E0503\nfn main() {\n    let mut value = 3;\n    // Create a mutable borrow of `value`.\n    let borrow = &mut value;\n    let _sum = value + 1; // error: cannot use `value` because\n                          //        it was mutably borrowed\n    println!(\"{}\", borrow);\n}\n```\n\nIn this example, `value` is mutably borrowed by `borrow` and cannot be\nused to calculate `sum`. This is not possible because this would violate\nRust's mutability rules.\n\nYou can fix this error by finishing using the borrow before the next use of\nthe value:\n\n```\nfn main() {\n    let mut value = 3;\n    let borrow = &mut value;\n    println!(\"{}\", borrow);\n    // The block has ended and with it the borrow.\n    // You can now use `value` again.\n    let _sum = value + 1;\n}\n```\n\nOr by cloning `value` before borrowing it:\n\n```\nfn main() {\n    let mut value = 3;\n    // We clone `value`, creating a copy.\n    let value_cloned = value.clone();\n    // The mutable borrow is a reference to `value` and\n    // not to `value_cloned`...\n    let borrow = &mut value;\n    // ... which means we can still use `value_cloned`,\n    let _sum = value_cloned + 1;\n    // even though the borrow only ends here.\n    println!(\"{}\", borrow);\n}\n```\n\nFor more information on Rust's ownership system, take a look at the\n[References & Borrowing][references-and-borrowing] section of the Book.\n\n[references-and-borrowing]: https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":3753,"byte_end":3757,"line_start":136,"line_end":136,"column_start":19,"column_end":23,"is_primary":false,"text":[{"text":"        let tab = self.active_tab();","highlight_start":19,"highlight_end":23}],"label":"`*self` is borrowed here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":10267,"byte_end":10287,"line_start":291,"line_end":291,"column_start":21,"column_end":41,"is_primary":true,"text":[{"text":"                    self.active_tab += 1;","highlight_start":21,"highlight_end":41}],"label":"use of borrowed `*self`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":11901,"byte_end":11925,"line_start":330,"line_end":330,"column_start":12,"column_end":36,"is_primary":false,"text":[{"text":"        if tab.cursor.position.line < tab.scroll_offset {","highlight_start":12,"highlight_end":36}],"label":"borrow later used here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0503]\u001b[0m\u001b[1m: cannot use `self.active_tab` because it was mutably borrowed\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:291:21\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m136\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         let tab = self.active_tab();\n    \u001b[1m\u001b[94m|\u001b[0m                   \u001b[1m\u001b[94m----\u001b[0m \u001b[1m\u001b[94m`*self` is borrowed here\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m291\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                     self.active_tab += 1;\n    \u001b[1m\u001b[94m|\u001b[0m                     \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91muse of borrowed `*self`\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m330\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         if tab.cursor.position.line < tab.scroll_offset {\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[94m------------------------\u001b[0m \u001b[1m\u001b[94mborrow later used here\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot use `self.active_tab` because it was mutably borrowed","code":{"code":"E0503","explanation":"A value was used after it was mutably borrowed.\n\nErroneous code example:\n\n```compile_fail,E0503\nfn main() {\n    let mut value = 3;\n    // Create a mutable borrow of `value`.\n    let borrow = &mut value;\n    let _sum = value + 1; // error: cannot use `value` because\n                          //        it was mutably borrowed\n    println!(\"{}\", borrow);\n}\n```\n\nIn this example, `value` is mutably borrowed by `borrow` and cannot be\nused to calculate `sum`. This is not possible because this would violate\nRust's mutability rules.\n\nYou can fix this error by finishing using the borrow before the next use of\nthe value:\n\n```\nfn main() {\n    let mut value = 3;\n    let borrow = &mut value;\n    println!(\"{}\", borrow);\n    // The block has ended and with it the borrow.\n    // You can now use `value` again.\n    let _sum = value + 1;\n}\n```\n\nOr by cloning `value` before borrowing it:\n\n```\nfn main() {\n    let mut value = 3;\n    // We clone `value`, creating a copy.\n    let value_cloned = value.clone();\n    // The mutable borrow is a reference to `value` and\n    // not to `value_cloned`...\n    let borrow = &mut value;\n    // ... which means we can still use `value_cloned`,\n    let _sum = value_cloned + 1;\n    // even though the borrow only ends here.\n    println!(\"{}\", borrow);\n}\n```\n\nFor more information on Rust's ownership system, take a look at the\n[References & Borrowing][references-and-borrowing] section of the Book.\n\n[references-and-borrowing]: https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":3753,"byte_end":3757,"line_start":136,"line_end":136,"column_start":19,"column_end":23,"is_primary":false,"text":[{"text":"        let tab = self.active_tab();","highlight_start":19,"highlight_end":23}],"label":"`*self` is borrowed here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":10378,"byte_end":10393,"line_start":295,"line_end":295,"column_start":20,"column_end":35,"is_primary":true,"text":[{"text":"                if self.active_tab > 0 {","highlight_start":20,"highlight_end":35}],"label":"use of borrowed `*self`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":11901,"byte_end":11925,"line_start":330,"line_end":330,"column_start":12,"column_end":36,"is_primary":false,"text":[{"text":"        if tab.cursor.position.line < tab.scroll_offset {","highlight_start":12,"highlight_end":36}],"label":"borrow later used here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0503]\u001b[0m\u001b[1m: cannot use `self.active_tab` because it was mutably borrowed\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:295:20\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m136\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         let tab = self.active_tab();\n    \u001b[1m\u001b[94m|\u001b[0m                   \u001b[1m\u001b[94m----\u001b[0m \u001b[1m\u001b[94m`*self` is borrowed here\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m295\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                 if self.active_tab > 0 {\n    \u001b[1m\u001b[94m|\u001b[0m                    \u001b[1m\u001b[91m^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91muse of borrowed `*self`\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m330\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         if tab.cursor.position.line < tab.scroll_offset {\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[94m------------------------\u001b[0m \u001b[1m\u001b[94mborrow later used here\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot use `self.active_tab` because it was mutably borrowed","code":{"code":"E0503","explanation":"A value was used after it was mutably borrowed.\n\nErroneous code example:\n\n```compile_fail,E0503\nfn main() {\n    let mut value = 3;\n    // Create a mutable borrow of `value`.\n    let borrow = &mut value;\n    let _sum = value + 1; // error: cannot use `value` because\n                          //        it was mutably borrowed\n    println!(\"{}\", borrow);\n}\n```\n\nIn this example, `value` is mutably borrowed by `borrow` and cannot be\nused to calculate `sum`. This is not possible because this would violate\nRust's mutability rules.\n\nYou can fix this error by finishing using the borrow before the next use of\nthe value:\n\n```\nfn main() {\n    let mut value = 3;\n    let borrow = &mut value;\n    println!(\"{}\", borrow);\n    // The block has ended and with it the borrow.\n    // You can now use `value` again.\n    let _sum = value + 1;\n}\n```\n\nOr by cloning `value` before borrowing it:\n\n```\nfn main() {\n    let mut value = 3;\n    // We clone `value`, creating a copy.\n    let value_cloned = value.clone();\n    // The mutable borrow is a reference to `value` and\n    // not to `value_cloned`...\n    let borrow = &mut value;\n    // ... which means we can still use `value_cloned`,\n    let _sum = value_cloned + 1;\n    // even though the borrow only ends here.\n    println!(\"{}\", borrow);\n}\n```\n\nFor more information on Rust's ownership system, take a look at the\n[References & Borrowing][references-and-borrowing] section of the Book.\n\n[references-and-borrowing]: https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":3753,"byte_end":3757,"line_start":136,"line_end":136,"column_start":19,"column_end":23,"is_primary":false,"text":[{"text":"        let tab = self.active_tab();","highlight_start":19,"highlight_end":23}],"label":"`*self` is borrowed here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":10420,"byte_end":10440,"line_start":296,"line_end":296,"column_start":21,"column_end":41,"is_primary":true,"text":[{"text":"                    self.active_tab -= 1;","highlight_start":21,"highlight_end":41}],"label":"use of borrowed `*self`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":11901,"byte_end":11925,"line_start":330,"line_end":330,"column_start":12,"column_end":36,"is_primary":false,"text":[{"text":"        if tab.cursor.position.line < tab.scroll_offset {","highlight_start":12,"highlight_end":36}],"label":"borrow later used here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0503]\u001b[0m\u001b[1m: cannot use `self.active_tab` because it was mutably borrowed\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:296:21\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m136\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         let tab = self.active_tab();\n    \u001b[1m\u001b[94m|\u001b[0m                   \u001b[1m\u001b[94m----\u001b[0m \u001b[1m\u001b[94m`*self` is borrowed here\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m296\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                     self.active_tab -= 1;\n    \u001b[1m\u001b[94m|\u001b[0m                     \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91muse of borrowed `*self`\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m330\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         if tab.cursor.position.line < tab.scroll_offset {\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[94m------------------------\u001b[0m \u001b[1m\u001b[94mborrow later used here\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot borrow `self.theme.name` as immutable because it is also borrowed as mutable","code":{"code":"E0502","explanation":"A variable already borrowed with a certain mutability (either mutable or\nimmutable) was borrowed again with a different mutability.\n\nErroneous code example:\n\n```compile_fail,E0502\nfn bar(x: &mut i32) {}\nfn foo(a: &mut i32) {\n    let y = &a; // a is borrowed as immutable.\n    bar(a); // error: cannot borrow `*a` as mutable because `a` is also borrowed\n            //        as immutable\n    println!(\"{}\", y);\n}\n```\n\nTo fix this error, ensure that you don't have any other references to the\nvariable before trying to access it with a different mutability:\n\n```\nfn bar(x: &mut i32) {}\nfn foo(a: &mut i32) {\n    bar(a);\n    let y = &a; // ok!\n    println!(\"{}\", y);\n}\n```\n\nFor more information on Rust's ownership system, take a look at the\n[References & Borrowing][references-and-borrowing] section of the Book.\n\n[references-and-borrowing]: https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":10794,"byte_end":10797,"line_start":306,"line_end":306,"column_start":54,"column_end":57,"is_primary":true,"text":[{"text":"                let current = themes.iter().position(|t| *t == self.theme.name).unwrap_or(0);","highlight_start":54,"highlight_end":57}],"label":"immutable borrow occurs here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":3753,"byte_end":3757,"line_start":136,"line_end":136,"column_start":19,"column_end":23,"is_primary":false,"text":[{"text":"        let tab = self.active_tab();","highlight_start":19,"highlight_end":23}],"label":"mutable borrow occurs here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":10804,"byte_end":10819,"line_start":306,"line_end":306,"column_start":64,"column_end":79,"is_primary":false,"text":[{"text":"                let current = themes.iter().position(|t| *t == self.theme.name).unwrap_or(0);","highlight_start":64,"highlight_end":79}],"label":"second borrow occurs due to use of `self.theme.name` in closure","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":11901,"byte_end":11925,"line_start":330,"line_end":330,"column_start":12,"column_end":36,"is_primary":false,"text":[{"text":"        if tab.cursor.position.line < tab.scroll_offset {","highlight_start":12,"highlight_end":36}],"label":"mutable borrow later used here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0502]\u001b[0m\u001b[1m: cannot borrow `self.theme.name` as immutable because it is also borrowed as mutable\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:306:54\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m136\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         let tab = self.active_tab();\n    \u001b[1m\u001b[94m|\u001b[0m                   \u001b[1m\u001b[94m----\u001b[0m \u001b[1m\u001b[94mmutable borrow occurs here\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m306\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                 let current = themes.iter().position(|t| *t == self.theme.name).unwrap_or(0);\n    \u001b[1m\u001b[94m|\u001b[0m                                                      \u001b[1m\u001b[91m^^^\u001b[0m       \u001b[1m\u001b[94m---------------\u001b[0m \u001b[1m\u001b[94msecond borrow occurs due to use of `self.theme.name` in closure\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                                                      \u001b[1m\u001b[91m|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                                                      \u001b[1m\u001b[91mimmutable borrow occurs here\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m330\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         if tab.cursor.position.line < tab.scroll_offset {\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[94m------------------------\u001b[0m \u001b[1m\u001b[94mmutable borrow later used here\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot assign to `self.theme` because it is borrowed","code":{"code":"E0506","explanation":"An attempt was made to assign to a borrowed value.\n\nErroneous code example:\n\n```compile_fail,E0506\nstruct FancyNum {\n    num: u8,\n}\n\nlet mut fancy_num = FancyNum { num: 5 };\nlet fancy_ref = &fancy_num;\nfancy_num = FancyNum { num: 6 };\n// error: cannot assign to `fancy_num` because it is borrowed\n\nprintln!(\"Num: {}, Ref: {}\", fancy_num.num, fancy_ref.num);\n```\n\nBecause `fancy_ref` still holds a reference to `fancy_num`, `fancy_num` can't\nbe assigned to a new value as it would invalidate the reference.\n\nAlternatively, we can move out of `fancy_num` into a second `fancy_num`:\n\n```\nstruct FancyNum {\n    num: u8,\n}\n\nlet mut fancy_num = FancyNum { num: 5 };\nlet moved_num = fancy_num;\nfancy_num = FancyNum { num: 6 };\n\nprintln!(\"Num: {}, Moved num: {}\", fancy_num.num, moved_num.num);\n```\n\nIf the value has to be borrowed, try limiting the lifetime of the borrow using\na scoped block:\n\n```\nstruct FancyNum {\n    num: u8,\n}\n\nlet mut fancy_num = FancyNum { num: 5 };\n\n{\n    let fancy_ref = &fancy_num;\n    println!(\"Ref: {}\", fancy_ref.num);\n}\n\n// Works because `fancy_ref` is no longer in scope\nfancy_num = FancyNum { num: 6 };\nprintln!(\"Num: {}\", fancy_num.num);\n```\n\nOr by moving the reference into a function:\n\n```\nstruct FancyNum {\n    num: u8,\n}\n\nfn print_fancy_ref(fancy_ref: &FancyNum){\n    println!(\"Ref: {}\", fancy_ref.num);\n}\n\nlet mut fancy_num = FancyNum { num: 5 };\n\nprint_fancy_ref(&fancy_num);\n\n// Works because function borrow has ended\nfancy_num = FancyNum { num: 6 };\nprintln!(\"Num: {}\", fancy_num.num);\n```\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":3753,"byte_end":3757,"line_start":136,"line_end":136,"column_start":19,"column_end":23,"is_primary":false,"text":[{"text":"        let tab = self.active_tab();","highlight_start":19,"highlight_end":23}],"label":"`self.theme` is borrowed here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":10908,"byte_end":10918,"line_start":308,"line_end":308,"column_start":17,"column_end":27,"is_primary":true,"text":[{"text":"                self.theme = Theme::get_theme(&themes[next]);","highlight_start":17,"highlight_end":27}],"label":"`self.theme` is assigned to here but it was already borrowed","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":11901,"byte_end":11925,"line_start":330,"line_end":330,"column_start":12,"column_end":36,"is_primary":false,"text":[{"text":"        if tab.cursor.position.line < tab.scroll_offset {","highlight_start":12,"highlight_end":36}],"label":"borrow later used here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0506]\u001b[0m\u001b[1m: cannot assign to `self.theme` because it is borrowed\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:308:17\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m136\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         let tab = self.active_tab();\n    \u001b[1m\u001b[94m|\u001b[0m                   \u001b[1m\u001b[94m----\u001b[0m \u001b[1m\u001b[94m`self.theme` is borrowed here\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m308\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                 self.theme = Theme::get_theme(&themes[next]);\n    \u001b[1m\u001b[94m|\u001b[0m                 \u001b[1m\u001b[91m^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91m`self.theme` is assigned to here but it was already borrowed\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m330\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         if tab.cursor.position.line < tab.scroll_offset {\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[94m------------------------\u001b[0m \u001b[1m\u001b[94mborrow later used here\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot borrow `self.highlighter` as immutable because it is also borrowed as mutable","code":{"code":"E0502","explanation":"A variable already borrowed with a certain mutability (either mutable or\nimmutable) was borrowed again with a different mutability.\n\nErroneous code example:\n\n```compile_fail,E0502\nfn bar(x: &mut i32) {}\nfn foo(a: &mut i32) {\n    let y = &a; // a is borrowed as immutable.\n    bar(a); // error: cannot borrow `*a` as mutable because `a` is also borrowed\n            //        as immutable\n    println!(\"{}\", y);\n}\n```\n\nTo fix this error, ensure that you don't have any other references to the\nvariable before trying to access it with a different mutability:\n\n```\nfn bar(x: &mut i32) {}\nfn foo(a: &mut i32) {\n    bar(a);\n    let y = &a; // ok!\n    println!(\"{}\", y);\n}\n```\n\nFor more information on Rust's ownership system, take a look at the\n[References & Borrowing][references-and-borrowing] section of the Book.\n\n[references-and-borrowing]: https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":11544,"byte_end":11560,"line_start":320,"line_end":320,"column_start":39,"column_end":55,"is_primary":true,"text":[{"text":"                if let Some(prefix) = self.highlighter.get_comment_prefix() {","highlight_start":39,"highlight_end":55}],"label":"immutable borrow occurs here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":3753,"byte_end":3757,"line_start":136,"line_end":136,"column_start":19,"column_end":23,"is_primary":false,"text":[{"text":"        let tab = self.active_tab();","highlight_start":19,"highlight_end":23}],"label":"mutable borrow occurs here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":11615,"byte_end":11639,"line_start":321,"line_end":321,"column_start":32,"column_end":56,"is_primary":false,"text":[{"text":"                    let line = tab.cursor.position.line;","highlight_start":32,"highlight_end":56}],"label":"mutable borrow later used here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0502]\u001b[0m\u001b[1m: cannot borrow `self.highlighter` as immutable because it is also borrowed as mutable\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:320:39\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m136\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         let tab = self.active_tab();\n    \u001b[1m\u001b[94m|\u001b[0m                   \u001b[1m\u001b[94m----\u001b[0m \u001b[1m\u001b[94mmutable borrow occurs here\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m320\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                 if let Some(prefix) = self.highlighter.get_comment_prefix() {\n    \u001b[1m\u001b[94m|\u001b[0m                                       \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mimmutable borrow occurs here\u001b[0m\n\u001b[1m\u001b[94m321\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                     let line = tab.cursor.position.line;\n    \u001b[1m\u001b[94m|\u001b[0m                                \u001b[1m\u001b[94m------------------------\u001b[0m \u001b[1m\u001b[94mmutable borrow later used here\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused variable: `layout`","code":{"code":"unused_variables","explanation":null},"level":"warning","spans":[{"file_name":"src/main.rs","byte_start":12451,"byte_end":12457,"line_start":348,"line_end":348,"column_start":13,"column_end":19,"is_primary":true,"text":[{"text":"        let layout = self.layout.get_layout(area);","highlight_start":13,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"if this is intentional, prefix it with an underscore","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":12451,"byte_end":12457,"line_start":348,"line_end":348,"column_start":13,"column_end":19,"is_primary":true,"text":[{"text":"        let layout = self.layout.get_layout(area);","highlight_start":13,"highlight_end":19}],"label":null,"suggested_replacement":"_layout","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unused variable: `layout`\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:348:13\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m348\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         let layout = self.layout.get_layout(area);\n    \u001b[1m\u001b[94m|\u001b[0m             \u001b[1m\u001b[33m^^^^^^\u001b[0m \u001b[1m\u001b[33mhelp: if this is intentional, prefix it with an underscore: `_layout`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: `#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default\n\n"}
{"$message_type":"diagnostic","message":"aborting due to 57 previous errors; 12 warnings emitted","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m: aborting due to 57 previous errors; 12 warnings emitted\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"Some errors have detailed explanations: E0277, E0308, E0382, E0432, E0433, E0499, E0502, E0503, E0506...","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[1mSome errors have detailed explanations: E0277, E0308, E0382, E0432, E0433, E0499, E0502, E0503, E0506...\u001b[0m\n"}
{"$message_type":"diagnostic","message":"For more information about an error, try `rustc --explain E0277`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[1mFor more information about an error, try `rustc --explain E0277`.\u001b[0m\n"}
